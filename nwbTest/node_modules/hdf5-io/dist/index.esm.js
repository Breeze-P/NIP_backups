class e{constructor(e,t={},s=!1){this.files=new Map,this._path="/hdf5-io",this._preprocess=e=>{},this._postprocess=e=>e,this._convertPath=e=>"/"===e[0]?e:`/${e}`,this.initFS=(e=this._path)=>new Promise((t=>{this._path=e=this._convertPath(e),this._FSReady().then((async()=>{this.reader.FS.mkdir(e),this.reader.FS.chdir(e);try{this.reader.FS.mount(this.reader.FS.filesystems.IDBFS,{},e),this._debug&&console.log(`Mounted IndexedDB filesystem to ${e}`),this.syncFS(!0,e),t(!0)}catch(s){switch(s.errno){case 44:console.warn("Path does not exist"),t(!1);break;case 10:console.warn(`Filesystem already mounted at ${e}`),this._debug&&console.log("Active Filesystem",await this.list(e)),t(!0);break;default:console.warn("Unknown filesystem error",s),t(!1)}}}))})),this.syncFS=(e=!1,t=this._path)=>(t=this._convertPath(t),new Promise((s=>{this._FSReady().then((async()=>{this._debug&&!e&&console.log(`Pushing all current files in ${t} to IndexedDB`),this.reader.FS.syncfs(e,(async i=>{if(i)console.error(i),s(!1);else{if(this._debug){const s=await this.list(t);e?console.log(`IndexedDB successfully read into ${t}!`,s):console.log(`All current files in ${t} pushed to IndexedDB!`,s)}s(!0)}}))}))}))),this.upload=async e=>{const t=e.target;t.files&&t.files?.length&&await Promise.all(Array.from(t.files).map((async e=>{let t=await e.arrayBuffer();await this._write(e.name,t)})))},this.list=async(e=this._path)=>{let t;e=this._convertPath(e),await this._FSReady();try{t=this.reader.FS.lookupPath(e)?.node}catch(e){console.warn(e)}if(t?.isFolder&&t.contents){let e=Object.values(t.contents).filter((e=>!e.isFolder)).map((e=>e.name));return e.forEach((e=>{this.files.has(e)||this.files.set(e,{name:e,file:void 0})})),e}return[]},this.download=(e,t,s="hdf5")=>{if(t||(t=e?this.files.get(e):[...this.files.values()][0]),t){e||(e=t.name),t.write&&t.write.flush(),t.read&&t.read.flush();const a=new Blob([this.reader.FS.readFile(t.name)],{type:"application/x-hdf5"});var i=document.createElement("a");document.body.appendChild(i),i.style.display="none";const o=globalThis.navigator;if(o?.msSaveOrOpenBlob)o.msSaveOrOpenBlob(a,e);else{var r=globalThis.URL?.createObjectURL(a);i.href=r;let t=e.replace(/(.+)\.(.+)/,"$1");i.download=t+`.${s}`,i.target="_blank",i.click(),setTimeout((function(){globalThis.URL.revokeObjectURL(r)}),1e3)}}},this.fetch=async(e,t="default.hdf5",s=(()=>{}),i=(()=>{}),r=!1)=>{let a=this.get(t,void 0,r)??{nwb:void 0};if(a.file)i(!1);else{const o=performance.now();let n=await fetch(e).then((e=>{if(e.body){const t=e.body.getReader(),r=e.headers.get("Content-Length");let a=0;const o=new ReadableStream({start(e){const o=async()=>{t.read().then((({value:t,done:n})=>{if(n)return i(!0),void e.close();a+=t?.length??0,s(a/r,r),e.enqueue(t),o()}))};o()}});return new Response(o,{headers:e.headers})}return new Response})),l=await n.arrayBuffer();const h=performance.now();this._debug&&console.log(`Fetched in ${h-o} ms`),await this._write(t,l),a.file=this.read(t,r)}return a.file},this._write=async(e,t)=>{const s=performance.now();await this._FSReady(),this.reader.FS.writeFile(e,new Uint8Array(t));const i=performance.now();return this._debug&&console.log(`Wrote raw file in ${i-s} ms`),!0},this._FSReady=()=>new Promise((e=>{this.reader.FS?e(!0):setTimeout((async()=>e(await this._FSReady())),10)})),this._parse=(e,t={},s,i={},r=!0)=>{if(e){if(e instanceof this.reader.Dataset)Object.keys(t[s]),t[s]=e.value;else if(!e.attrs.value)for(let i in e.attrs)t[s][i]=e.attrs[i].value;if(e.keys instanceof Function){e.keys().forEach((a=>{const o=e.get(a);t[s][a]={},t[s][a]=this._parse(o,t[s],a,i,r)}))}}return t[s]},this.read=(e=[...this.files.keys()][0],t=!1)=>{let s=this.get(e,"r",t);if(-1!=Number(s?.read?.file_id)){const e=performance.now(),t=this._preprocess(s);let i="res",r={[i]:{}};this._parse(s.read,r,i,t),s.file=this._postprocess(r[i]);const a=performance.now();return this._debug&&console.log(`Read file in ${a-e} ms`),s.file}},this.get=(e=[...this.files.keys()][0],t,s=!1)=>{let i=this.files.get(e);if(i||(i={name:e,file:null},this.files.set(e,i)),t){let s=new this.reader.File(e,t);"w"===t?i.write=s:"r"===t?i.read=s:"a"===t&&(i.read=i.write=s)}else!s&&e&&void 0===i.file&&(this._debug&&console.log(`Returning local version from ${this._path}`),this.read(e));return i},this.save=e=>this.syncFS(!1,e),this.write=(e,t=[...this.files.keys()][0])=>{let s=this.get(t,"w");if(-1!=Number(s?.write?.file_id)){const t=performance.now();let i=(e,t)=>{const r=t?s.write.get(t):s.write;for(let a in e){const o=`${t?`${t}/`:""}${a}`;e[a]instanceof Function||("object"==typeof e[a]?e[a]instanceof Array?r.create_dataset(a,e[a]):(s.write.create_group(o),i(e[a],o)):e[a]&&r.create_attribute(a,e[a]))}};i(e);const r=performance.now();this._debug&&console.log(`Wrote NWB File object to browser filesystem in ${r-t} ms`)}},this.close=(e=[...this.files.keys()][0])=>{const t=this.files.get(e);t&&(t.read&&t.read.close(),t.write&&t.write.close(),this.files.delete(e))},this.reader=e,this._debug=s,t?.preprocess&&(this._preprocess=t.preprocess),t?.postprocess&&(this._postprocess=t.postprocess)}}export{e as default};
