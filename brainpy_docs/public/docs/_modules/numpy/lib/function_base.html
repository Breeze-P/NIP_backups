

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>numpy.lib.function_base &#8212; BrainPy documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/numpy/lib/function_base';</script>
    <link rel="shortcut icon" href="../../../_static/logo-square.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Quickstart</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/simulation.html">Simulating a Brain Dynamics Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/training.html">Training a Brain Dynamics Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/analysis.html">Analyzing a Brain Dynamics Model</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">BrainPy Core Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../core_concept/brainpy_transform_concept.html">Concept 1: Object-oriented Transformation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core_concept/brainpy_dynamical_system.html">Concept 2: Dynamical System</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Brain Dynamics Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial_math/index.html">Math Foundation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_math/variables.html"><code class="docutils literal notranslate"><span class="pre">brainpy.math.Variable</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_math/control_flows.html">Control Flows for JIT compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_math/random_number_generation.html">Random Number Generation for JIT Compilation</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial_building/index.html">Model Building</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/overview_of_dynamic_model.html">Using Built-in Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/build_conductance_neurons.html">Building Conductance-based Neuron Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/build_synapse_models.html">Building Synapse Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/build_network_models.html">Building Network Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/customize_neuron_models.html">Customizing Your Neuron Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_building/customize_synapse_models.html">Customizing Your Synapse Models</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial_simulation/index.html">Model Simulation</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_simulation/simulation_dsrunner.html">Simulation with <code class="docutils literal notranslate"><span class="pre">DSRunner</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_simulation/parallel_computing.html">Parallel Simulation for Parameter Exploration</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial_training/index.html">Model Training</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_training/build_training_models.html">Building Training Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_training/offline_training.html">Training with Offline Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_training/online_training.html">Training with Online Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_training/bp_training.html">Training with Back-propagation Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_training/esn_introduction.html">Introduction to Echo State Network</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial_analysis/index.html">Model Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_analysis/lowdim_analysis.html">Low-dimensional Analyzers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_analysis/highdim_analysis.html">High-dimensional Analyzers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial_analysis/decision_making_model.html">Analysis of a Decision-making Model</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Advanced Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_advanced/adavanced_lowdim_analysis.html">How does low-dimensional analyzers work?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_advanced/interoperation.html">Interoperation with other JAX frameworks</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/ode_numerical_solvers.html">Numerical Solvers for Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/sde_numerical_solvers.html">Numerical Solvers for Stochastic Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/fde_numerical_solvers.html">Numerical Solvers for Fractional Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/dde_numerical_solvers.html">Numerical Solvers for Delay Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/joint_equations.html">Joint Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/synaptic_connections.html">Synaptic Connections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/synaptic_weights.html">Synaptic Weights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/optimizers.html">Gradient Descent Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/saving_and_loading.html">Saving and Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_toolbox/inputs.html">Inputs Construction</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Frequently Asked Questions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_FAQs/citing_and_publication.html">How to cite BrainPy?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_FAQs/uniqueness_of-brainpy-math.html">How is <code class="docutils literal notranslate"><span class="pre">brainpy</span></code> different from other frameworks?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_FAQs/brainpy_ecosystem.html">BrainPy Ecosystem for Brain Dynamics Modeling</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/brainpy.html"><code class="docutils literal notranslate"><span class="pre">brainpy</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.Integrator.html">brainpy.Integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.JointEq.html">brainpy.JointEq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.IntegratorRunner.html">brainpy.IntegratorRunner</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.odeint.html">brainpy.odeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.sdeint.html">brainpy.sdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.fdeint.html">brainpy.fdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.DynamicalSystem.html">brainpy.DynamicalSystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.Container.html">brainpy.Container</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.Sequential.html">brainpy.Sequential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.Network.html">brainpy.Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.NeuGroup.html">brainpy.NeuGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.SynConn.html">brainpy.SynConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.SynOut.html">brainpy.SynOut</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.SynSTP.html">brainpy.SynSTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.SynLTP.html">brainpy.SynLTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.TwoEndConn.html">brainpy.TwoEndConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.CondNeuGroup.html">brainpy.CondNeuGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.Channel.html">brainpy.Channel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.DSRunner.html">brainpy.DSRunner</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.DSTrainer.html">brainpy.DSTrainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.BPTT.html">brainpy.BPTT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.BPFF.html">brainpy.BPFF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.OnlineTrainer.html">brainpy.OnlineTrainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.ForceTrainer.html">brainpy.ForceTrainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.OfflineTrainer.html">brainpy.OfflineTrainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.RidgeTrainer.html">brainpy.RidgeTrainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.NoSharedArg.html">brainpy.NoSharedArg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.LoopOverTime.html">brainpy.LoopOverTime</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/math.html"><code class="docutils literal notranslate"><span class="pre">brainpy.math</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.BrainPyObject.html">brainpy.math.BrainPyObject</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.FunAsObject.html">brainpy.math.FunAsObject</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dyn_seq.html">brainpy.math.dyn_seq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dyn_dict.html">brainpy.math.dyn_dict</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.Variable.html">brainpy.math.Variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.Parameter.html">brainpy.math.Parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.TrainVar.html">brainpy.math.TrainVar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.Partial.html">brainpy.math.Partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.grad.html">brainpy.math.grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.vector_grad.html">brainpy.math.vector_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.jacobian.html">brainpy.math.jacobian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.jacrev.html">brainpy.math.jacrev</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.jacfwd.html">brainpy.math.jacfwd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hessian.html">brainpy.math.hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.make_loop.html">brainpy.math.make_loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.make_while.html">brainpy.math.make_while</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.make_cond.html">brainpy.math.make_cond</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cond.html">brainpy.math.cond</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ifelse.html">brainpy.math.ifelse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.for_loop.html">brainpy.math.for_loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.while_loop.html">brainpy.math.while_loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.to_object.html">brainpy.math.to_object</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.to_dynsys.html">brainpy.math.to_dynsys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.function.html">brainpy.math.function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.jit.html">brainpy.math.jit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ObjectTransform.html">brainpy.math.ObjectTransform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_sum.html">brainpy.math.pre2post_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_prod.html">brainpy.math.pre2post_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_max.html">brainpy.math.pre2post_max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_min.html">brainpy.math.pre2post_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_mean.html">brainpy.math.pre2post_mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_event_sum.html">brainpy.math.pre2post_event_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_coo_event_sum.html">brainpy.math.pre2post_coo_event_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2post_event_prod.html">brainpy.math.pre2post_event_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pre2syn.html">brainpy.math.pre2syn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_sum.html">brainpy.math.syn2post_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post.html">brainpy.math.syn2post</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_prod.html">brainpy.math.syn2post_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_max.html">brainpy.math.syn2post_max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_min.html">brainpy.math.syn2post_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_mean.html">brainpy.math.syn2post_mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.syn2post_softmax.html">brainpy.math.syn2post_softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sparse_matmul.html">brainpy.math.sparse_matmul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.csr_matvec.html">brainpy.math.csr_matvec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.event_csr_matvec.html">brainpy.math.event_csr_matvec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.XLACustomOp.html">brainpy.math.XLACustomOp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.celu.html">brainpy.math.celu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.elu.html">brainpy.math.elu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.gelu.html">brainpy.math.gelu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.glu.html">brainpy.math.glu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hard_tanh.html">brainpy.math.hard_tanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hard_sigmoid.html">brainpy.math.hard_sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hard_silu.html">brainpy.math.hard_silu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hard_swish.html">brainpy.math.hard_swish</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.leaky_relu.html">brainpy.math.leaky_relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log_sigmoid.html">brainpy.math.log_sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log_softmax.html">brainpy.math.log_softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.one_hot.html">brainpy.math.one_hot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.normalize.html">brainpy.math.normalize</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.relu.html">brainpy.math.relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.relu6.html">brainpy.math.relu6</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sigmoid.html">brainpy.math.sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.soft_sign.html">brainpy.math.soft_sign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.softmax.html">brainpy.math.softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.softplus.html">brainpy.math.softplus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.silu.html">brainpy.math.silu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.swish.html">brainpy.math.swish</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.selu.html">brainpy.math.selu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.identity.html">brainpy.math.identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.TimeDelay.html">brainpy.math.TimeDelay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.LengthDelay.html">brainpy.math.LengthDelay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.NeuTimeDelay.html">brainpy.math.NeuTimeDelay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.NeuLenDelay.html">brainpy.math.NeuLenDelay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.DelayVariable.html">brainpy.math.DelayVariable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ROTATE_UPDATE.html">brainpy.math.ROTATE_UPDATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.CONCAT_UPDATE.html">brainpy.math.CONCAT_UPDATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_float.html">brainpy.math.set_float</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_float.html">brainpy.math.get_float</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_int.html">brainpy.math.set_int</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_int.html">brainpy.math.get_int</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_bool.html">brainpy.math.set_bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_bool.html">brainpy.math.get_bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_complex.html">brainpy.math.set_complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_complex.html">brainpy.math.get_complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_dt.html">brainpy.math.set_dt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_dt.html">brainpy.math.get_dt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_mode.html">brainpy.math.set_mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_mode.html">brainpy.math.get_mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_environment.html">brainpy.math.set_environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.enable_x64.html">brainpy.math.enable_x64</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.disable_x64.html">brainpy.math.disable_x64</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_platform.html">brainpy.math.set_platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_platform.html">brainpy.math.get_platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_host_device_count.html">brainpy.math.set_host_device_count</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.clear_buffer_memory.html">brainpy.math.clear_buffer_memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.enable_gpu_memory_preallocation.html">brainpy.math.enable_gpu_memory_preallocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.disable_gpu_memory_preallocation.html">brainpy.math.disable_gpu_memory_preallocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ditype.html">brainpy.math.ditype</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dftype.html">brainpy.math.dftype</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.environment.html">brainpy.math.environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.batching_environment.html">brainpy.math.batching_environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.training_environment.html">brainpy.math.training_environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.Mode.html">brainpy.math.Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.NonBatchingMode.html">brainpy.math.NonBatchingMode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.BatchingMode.html">brainpy.math.BatchingMode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.TrainingMode.html">brainpy.math.TrainingMode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nonbatching_mode.html">brainpy.math.nonbatching_mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.batching_mode.html">brainpy.math.batching_mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.training_mode.html">brainpy.math.training_mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.as_device_array.html">brainpy.math.as_device_array</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.as_jax.html">brainpy.math.as_jax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.as_ndarray.html">brainpy.math.as_ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.as_numpy.html">brainpy.math.as_numpy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.as_variable.html">brainpy.math.as_variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fill_diagonal.html">brainpy.math.fill_diagonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.empty.html">brainpy.math.empty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.empty_like.html">brainpy.math.empty_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ones.html">brainpy.math.ones</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ones_like.html">brainpy.math.ones_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.zeros.html">brainpy.math.zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.zeros_like.html">brainpy.math.zeros_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array.html">brainpy.math.array</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asarray.html">brainpy.math.asarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arange.html">brainpy.math.arange</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linspace.html">brainpy.math.linspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logspace.html">brainpy.math.logspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.full.html">brainpy.math.full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.full_like.html">brainpy.math.full_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.eye.html">brainpy.math.eye</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.identity.html">brainpy.math.identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diag.html">brainpy.math.diag</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tri.html">brainpy.math.tri</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tril.html">brainpy.math.tril</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.triu.html">brainpy.math.triu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.real.html">brainpy.math.real</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.imag.html">brainpy.math.imag</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.conj.html">brainpy.math.conj</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.conjugate.html">brainpy.math.conjugate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ndim.html">brainpy.math.ndim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isreal.html">brainpy.math.isreal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isscalar.html">brainpy.math.isscalar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.add.html">brainpy.math.add</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reciprocal.html">brainpy.math.reciprocal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.negative.html">brainpy.math.negative</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.positive.html">brainpy.math.positive</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.multiply.html">brainpy.math.multiply</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.divide.html">brainpy.math.divide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.power.html">brainpy.math.power</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.subtract.html">brainpy.math.subtract</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.true_divide.html">brainpy.math.true_divide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.floor_divide.html">brainpy.math.floor_divide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.float_power.html">brainpy.math.float_power</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fmod.html">brainpy.math.fmod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.mod.html">brainpy.math.mod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.modf.html">brainpy.math.modf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.divmod.html">brainpy.math.divmod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.remainder.html">brainpy.math.remainder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.abs.html">brainpy.math.abs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.exp.html">brainpy.math.exp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.exp2.html">brainpy.math.exp2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.expm1.html">brainpy.math.expm1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log.html">brainpy.math.log</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log10.html">brainpy.math.log10</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log1p.html">brainpy.math.log1p</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.log2.html">brainpy.math.log2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logaddexp.html">brainpy.math.logaddexp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logaddexp2.html">brainpy.math.logaddexp2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.lcm.html">brainpy.math.lcm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.gcd.html">brainpy.math.gcd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arccos.html">brainpy.math.arccos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arccosh.html">brainpy.math.arccosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arcsin.html">brainpy.math.arcsin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arcsinh.html">brainpy.math.arcsinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arctan.html">brainpy.math.arctan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arctan2.html">brainpy.math.arctan2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arctanh.html">brainpy.math.arctanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cos.html">brainpy.math.cos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cosh.html">brainpy.math.cosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sin.html">brainpy.math.sin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sinc.html">brainpy.math.sinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sinh.html">brainpy.math.sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tan.html">brainpy.math.tan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tanh.html">brainpy.math.tanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.deg2rad.html">brainpy.math.deg2rad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hypot.html">brainpy.math.hypot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.rad2deg.html">brainpy.math.rad2deg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.degrees.html">brainpy.math.degrees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.radians.html">brainpy.math.radians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.round.html">brainpy.math.round</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.around.html">brainpy.math.around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.round_.html">brainpy.math.round_</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.rint.html">brainpy.math.rint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.floor.html">brainpy.math.floor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ceil.html">brainpy.math.ceil</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.trunc.html">brainpy.math.trunc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fix.html">brainpy.math.fix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.prod.html">brainpy.math.prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sum.html">brainpy.math.sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diff.html">brainpy.math.diff</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.median.html">brainpy.math.median</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nancumprod.html">brainpy.math.nancumprod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nancumsum.html">brainpy.math.nancumsum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanprod.html">brainpy.math.nanprod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nansum.html">brainpy.math.nansum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cumprod.html">brainpy.math.cumprod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cumsum.html">brainpy.math.cumsum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ediff1d.html">brainpy.math.ediff1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cross.html">brainpy.math.cross</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.trapz.html">brainpy.math.trapz</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isfinite.html">brainpy.math.isfinite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isinf.html">brainpy.math.isinf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isnan.html">brainpy.math.isnan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.signbit.html">brainpy.math.signbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.copysign.html">brainpy.math.copysign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nextafter.html">brainpy.math.nextafter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ldexp.html">brainpy.math.ldexp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.frexp.html">brainpy.math.frexp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.convolve.html">brainpy.math.convolve</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sqrt.html">brainpy.math.sqrt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cbrt.html">brainpy.math.cbrt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.square.html">brainpy.math.square</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.absolute.html">brainpy.math.absolute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fabs.html">brainpy.math.fabs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sign.html">brainpy.math.sign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.heaviside.html">brainpy.math.heaviside</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.maximum.html">brainpy.math.maximum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.minimum.html">brainpy.math.minimum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fmax.html">brainpy.math.fmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fmin.html">brainpy.math.fmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.interp.html">brainpy.math.interp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.clip.html">brainpy.math.clip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.angle.html">brainpy.math.angle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bitwise_and.html">brainpy.math.bitwise_and</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bitwise_not.html">brainpy.math.bitwise_not</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bitwise_or.html">brainpy.math.bitwise_or</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bitwise_xor.html">brainpy.math.bitwise_xor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.invert.html">brainpy.math.invert</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.left_shift.html">brainpy.math.left_shift</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.right_shift.html">brainpy.math.right_shift</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.equal.html">brainpy.math.equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.not_equal.html">brainpy.math.not_equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.greater.html">brainpy.math.greater</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.greater_equal.html">brainpy.math.greater_equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.less.html">brainpy.math.less</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.less_equal.html">brainpy.math.less_equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array_equal.html">brainpy.math.array_equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isclose.html">brainpy.math.isclose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.allclose.html">brainpy.math.allclose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logical_and.html">brainpy.math.logical_and</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logical_not.html">brainpy.math.logical_not</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logical_or.html">brainpy.math.logical_or</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.logical_xor.html">brainpy.math.logical_xor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.all.html">brainpy.math.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.any.html">brainpy.math.any</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.alltrue.html">brainpy.math.alltrue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sometrue.html">brainpy.math.sometrue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.shape.html">brainpy.math.shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.size.html">brainpy.math.size</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reshape.html">brainpy.math.reshape</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ravel.html">brainpy.math.ravel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.moveaxis.html">brainpy.math.moveaxis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.transpose.html">brainpy.math.transpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.swapaxes.html">brainpy.math.swapaxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.concatenate.html">brainpy.math.concatenate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.stack.html">brainpy.math.stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.vstack.html">brainpy.math.vstack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hstack.html">brainpy.math.hstack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dstack.html">brainpy.math.dstack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.column_stack.html">brainpy.math.column_stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.split.html">brainpy.math.split</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dsplit.html">brainpy.math.dsplit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hsplit.html">brainpy.math.hsplit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.vsplit.html">brainpy.math.vsplit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tile.html">brainpy.math.tile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.repeat.html">brainpy.math.repeat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unique.html">brainpy.math.unique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.append.html">brainpy.math.append</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.flip.html">brainpy.math.flip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fliplr.html">brainpy.math.fliplr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.flipud.html">brainpy.math.flipud</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.roll.html">brainpy.math.roll</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atleast_1d.html">brainpy.math.atleast_1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atleast_2d.html">brainpy.math.atleast_2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atleast_3d.html">brainpy.math.atleast_3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.expand_dims.html">brainpy.math.expand_dims</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.squeeze.html">brainpy.math.squeeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sort.html">brainpy.math.sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.argsort.html">brainpy.math.argsort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.argmax.html">brainpy.math.argmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.argmin.html">brainpy.math.argmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.argwhere.html">brainpy.math.argwhere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nonzero.html">brainpy.math.nonzero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.flatnonzero.html">brainpy.math.flatnonzero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.where.html">brainpy.math.where</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.searchsorted.html">brainpy.math.searchsorted</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.extract.html">brainpy.math.extract</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.count_nonzero.html">brainpy.math.count_nonzero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.max.html">brainpy.math.max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.min.html">brainpy.math.min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.amax.html">brainpy.math.amax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.amin.html">brainpy.math.amin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array_split.html">brainpy.math.array_split</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.meshgrid.html">brainpy.math.meshgrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.vander.html">brainpy.math.vander</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tril_indices.html">brainpy.math.tril_indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tril_indices_from.html">brainpy.math.tril_indices_from</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.triu_indices.html">brainpy.math.triu_indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.triu_indices_from.html">brainpy.math.triu_indices_from</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.take.html">brainpy.math.take</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.select.html">brainpy.math.select</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanmin.html">brainpy.math.nanmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanmax.html">brainpy.math.nanmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ptp.html">brainpy.math.ptp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.percentile.html">brainpy.math.percentile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanpercentile.html">brainpy.math.nanpercentile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.quantile.html">brainpy.math.quantile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanquantile.html">brainpy.math.nanquantile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.average.html">brainpy.math.average</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.mean.html">brainpy.math.mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.std.html">brainpy.math.std</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.var.html">brainpy.math.var</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanmedian.html">brainpy.math.nanmedian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanmean.html">brainpy.math.nanmean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanstd.html">brainpy.math.nanstd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanvar.html">brainpy.math.nanvar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.corrcoef.html">brainpy.math.corrcoef</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.correlate.html">brainpy.math.correlate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cov.html">brainpy.math.cov</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.histogram.html">brainpy.math.histogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bincount.html">brainpy.math.bincount</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.digitize.html">brainpy.math.digitize</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.bartlett.html">brainpy.math.bartlett</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.blackman.html">brainpy.math.blackman</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hamming.html">brainpy.math.hamming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.hanning.html">brainpy.math.hanning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.kaiser.html">brainpy.math.kaiser</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dot.html">brainpy.math.dot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.vdot.html">brainpy.math.vdot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.inner.html">brainpy.math.inner</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.outer.html">brainpy.math.outer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.kron.html">brainpy.math.kron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.matmul.html">brainpy.math.matmul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.trace.html">brainpy.math.trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.product.html">brainpy.math.product</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.row_stack.html">brainpy.math.row_stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.apply_over_axes.html">brainpy.math.apply_over_axes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.apply_along_axis.html">brainpy.math.apply_along_axis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array_equiv.html">brainpy.math.array_equiv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array_repr.html">brainpy.math.array_repr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array_str.html">brainpy.math.array_str</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.block.html">brainpy.math.block</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.broadcast_arrays.html">brainpy.math.broadcast_arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.broadcast_shapes.html">brainpy.math.broadcast_shapes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.broadcast_to.html">brainpy.math.broadcast_to</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.compress.html">brainpy.math.compress</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cumproduct.html">brainpy.math.cumproduct</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diag_indices.html">brainpy.math.diag_indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diag_indices_from.html">brainpy.math.diag_indices_from</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diagflat.html">brainpy.math.diagflat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.diagonal.html">brainpy.math.diagonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.einsum.html">brainpy.math.einsum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.einsum_path.html">brainpy.math.einsum_path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.geomspace.html">brainpy.math.geomspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.gradient.html">brainpy.math.gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.histogram2d.html">brainpy.math.histogram2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.histogram_bin_edges.html">brainpy.math.histogram_bin_edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.histogramdd.html">brainpy.math.histogramdd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.i0.html">brainpy.math.i0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.in1d.html">brainpy.math.in1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.indices.html">brainpy.math.indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.insert.html">brainpy.math.insert</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.intersect1d.html">brainpy.math.intersect1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.iscomplex.html">brainpy.math.iscomplex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isin.html">brainpy.math.isin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ix_.html">brainpy.math.ix_</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.lexsort.html">brainpy.math.lexsort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.load.html">brainpy.math.load</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.save.html">brainpy.math.save</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.savez.html">brainpy.math.savez</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.mask_indices.html">brainpy.math.mask_indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.msort.html">brainpy.math.msort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nan_to_num.html">brainpy.math.nan_to_num</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanargmax.html">brainpy.math.nanargmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.setdiff1d.html">brainpy.math.setdiff1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.nanargmin.html">brainpy.math.nanargmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pad.html">brainpy.math.pad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.poly.html">brainpy.math.poly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polyadd.html">brainpy.math.polyadd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polyder.html">brainpy.math.polyder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polyfit.html">brainpy.math.polyfit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polyint.html">brainpy.math.polyint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polymul.html">brainpy.math.polymul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polysub.html">brainpy.math.polysub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polyval.html">brainpy.math.polyval</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.resize.html">brainpy.math.resize</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.rollaxis.html">brainpy.math.rollaxis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.roots.html">brainpy.math.roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.rot90.html">brainpy.math.rot90</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.setxor1d.html">brainpy.math.setxor1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.tensordot.html">brainpy.math.tensordot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.trim_zeros.html">brainpy.math.trim_zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.union1d.html">brainpy.math.union1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unravel_index.html">brainpy.math.unravel_index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unwrap.html">brainpy.math.unwrap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.take_along_axis.html">brainpy.math.take_along_axis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.can_cast.html">brainpy.math.can_cast</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.choose.html">brainpy.math.choose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.copy.html">brainpy.math.copy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.frombuffer.html">brainpy.math.frombuffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fromfile.html">brainpy.math.fromfile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fromfunction.html">brainpy.math.fromfunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fromiter.html">brainpy.math.fromiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fromstring.html">brainpy.math.fromstring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.get_printoptions.html">brainpy.math.get_printoptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.iscomplexobj.html">brainpy.math.iscomplexobj</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isneginf.html">brainpy.math.isneginf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isposinf.html">brainpy.math.isposinf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.isrealobj.html">brainpy.math.isrealobj</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.issubdtype.html">brainpy.math.issubdtype</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.issubsctype.html">brainpy.math.issubsctype</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.iterable.html">brainpy.math.iterable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.packbits.html">brainpy.math.packbits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.piecewise.html">brainpy.math.piecewise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.printoptions.html">brainpy.math.printoptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.set_printoptions.html">brainpy.math.set_printoptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.promote_types.html">brainpy.math.promote_types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ravel_multi_index.html">brainpy.math.ravel_multi_index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.result_type.html">brainpy.math.result_type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.sort_complex.html">brainpy.math.sort_complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unpackbits.html">brainpy.math.unpackbits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.delete.html">brainpy.math.delete</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.add_newdoc.html">brainpy.math.add_newdoc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.array2string.html">brainpy.math.array2string</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asanyarray.html">brainpy.math.asanyarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.ascontiguousarray.html">brainpy.math.ascontiguousarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asfarray.html">brainpy.math.asfarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asscalar.html">brainpy.math.asscalar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.common_type.html">brainpy.math.common_type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.disp.html">brainpy.math.disp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.genfromtxt.html">brainpy.math.genfromtxt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.loadtxt.html">brainpy.math.loadtxt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.info.html">brainpy.math.info</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.issubclass_.html">brainpy.math.issubclass_</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.place.html">brainpy.math.place</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.polydiv.html">brainpy.math.polydiv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.put.html">brainpy.math.put</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.putmask.html">brainpy.math.putmask</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.safe_eval.html">brainpy.math.safe_eval</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.savetxt.html">brainpy.math.savetxt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.savez_compressed.html">brainpy.math.savez_compressed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.show_config.html">brainpy.math.show_config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.typename.html">brainpy.math.typename</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.copyto.html">brainpy.math.copyto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.matrix.html">brainpy.math.matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asmatrix.html">brainpy.math.asmatrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.mat.html">brainpy.math.mat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.dtype.html">brainpy.math.dtype</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.finfo.html">brainpy.math.finfo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.iinfo.html">brainpy.math.iinfo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.e.html">brainpy.math.e</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.pi.html">brainpy.math.pi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.inf.html">brainpy.math.inf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.add_docstring.html">brainpy.math.add_docstring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.add_newdoc_ufunc.html">brainpy.math.add_newdoc_ufunc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.flatten.html">brainpy.math.flatten</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cat.html">brainpy.math.cat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsqueeze.html">brainpy.math.unsqueeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.abs.html">brainpy.math.abs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.absolute.html">brainpy.math.absolute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.acos.html">brainpy.math.acos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arccos.html">brainpy.math.arccos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.acosh.html">brainpy.math.acosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arccosh.html">brainpy.math.arccosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.add.html">brainpy.math.add</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.addcdiv.html">brainpy.math.addcdiv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.addcmul.html">brainpy.math.addcmul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.angle.html">brainpy.math.angle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asin.html">brainpy.math.asin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arcsin.html">brainpy.math.arcsin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.asinh.html">brainpy.math.asinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atan.html">brainpy.math.atan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.arctan.html">brainpy.math.arctan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atan2.html">brainpy.math.atan2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.atanh.html">brainpy.math.atanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.Tensor.html">brainpy.math.Tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.concat.html">brainpy.math.concat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_sum.html">brainpy.math.reduce_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_max.html">brainpy.math.reduce_max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_min.html">brainpy.math.reduce_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_mean.html">brainpy.math.reduce_mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_all.html">brainpy.math.reduce_all</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_any.html">brainpy.math.reduce_any</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_logsumexp.html">brainpy.math.reduce_logsumexp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_prod.html">brainpy.math.reduce_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_std.html">brainpy.math.reduce_std</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_variance.html">brainpy.math.reduce_variance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.reduce_euclidean_norm.html">brainpy.math.reduce_euclidean_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_sqrt_n.html">brainpy.math.unsorted_segment_sqrt_n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.segment_mean.html">brainpy.math.segment_mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_sum.html">brainpy.math.unsorted_segment_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_prod.html">brainpy.math.unsorted_segment_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_max.html">brainpy.math.unsorted_segment_max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_min.html">brainpy.math.unsorted_segment_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.unsorted_segment_mean.html">brainpy.math.unsorted_segment_mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.segment_sum.html">brainpy.math.segment_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.segment_prod.html">brainpy.math.segment_prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.segment_max.html">brainpy.math.segment_max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.segment_min.html">brainpy.math.segment_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.clip_by_value.html">brainpy.math.clip_by_value</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.cast.html">brainpy.math.cast</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.sigmoid.html">brainpy.math.surrogate.sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.piecewise_quadratic.html">brainpy.math.surrogate.piecewise_quadratic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.piecewise_exp.html">brainpy.math.surrogate.piecewise_exp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.soft_sign.html">brainpy.math.surrogate.soft_sign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.arctan.html">brainpy.math.surrogate.arctan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.nonzero_sign_log.html">brainpy.math.surrogate.nonzero_sign_log</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.erf.html">brainpy.math.surrogate.erf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.piecewise_leaky_relu.html">brainpy.math.surrogate.piecewise_leaky_relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.squarewave_fourier_series.html">brainpy.math.surrogate.squarewave_fourier_series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.s2nn.html">brainpy.math.surrogate.s2nn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.q_pseudo_spike.html">brainpy.math.surrogate.q_pseudo_spike</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.leaky_relu.html">brainpy.math.surrogate.leaky_relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.log_tailed_relu.html">brainpy.math.surrogate.log_tailed_relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.relu_grad.html">brainpy.math.surrogate.relu_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.gaussian_grad.html">brainpy.math.surrogate.gaussian_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.inv_square_grad.html">brainpy.math.surrogate.inv_square_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.multi_gaussian_grad.html">brainpy.math.surrogate.multi_gaussian_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.slayer_grad.html">brainpy.math.surrogate.slayer_grad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.inv_square_grad2.html">brainpy.math.surrogate.inv_square_grad2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.surrogate.relu_grad2.html">brainpy.math.surrogate.relu_grad2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.seed.html">brainpy.math.random.seed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.split_key.html">brainpy.math.random.split_key</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.default_rng.html">brainpy.math.random.default_rng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.rand.html">brainpy.math.random.rand</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.randint.html">brainpy.math.random.randint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.random_integers.html">brainpy.math.random.random_integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.randn.html">brainpy.math.random.randn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.random.html">brainpy.math.random.random</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.random_sample.html">brainpy.math.random.random_sample</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.ranf.html">brainpy.math.random.ranf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.sample.html">brainpy.math.random.sample</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.choice.html">brainpy.math.random.choice</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.permutation.html">brainpy.math.random.permutation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.shuffle.html">brainpy.math.random.shuffle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.beta.html">brainpy.math.random.beta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.exponential.html">brainpy.math.random.exponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.gamma.html">brainpy.math.random.gamma</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.gumbel.html">brainpy.math.random.gumbel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.laplace.html">brainpy.math.random.laplace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.logistic.html">brainpy.math.random.logistic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.normal.html">brainpy.math.random.normal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.pareto.html">brainpy.math.random.pareto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.poisson.html">brainpy.math.random.poisson</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.standard_cauchy.html">brainpy.math.random.standard_cauchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.standard_exponential.html">brainpy.math.random.standard_exponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.standard_gamma.html">brainpy.math.random.standard_gamma</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.standard_normal.html">brainpy.math.random.standard_normal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.standard_t.html">brainpy.math.random.standard_t</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.uniform.html">brainpy.math.random.uniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.truncated_normal.html">brainpy.math.random.truncated_normal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.bernoulli.html">brainpy.math.random.bernoulli</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.lognormal.html">brainpy.math.random.lognormal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.binomial.html">brainpy.math.random.binomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.chisquare.html">brainpy.math.random.chisquare</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.dirichlet.html">brainpy.math.random.dirichlet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.geometric.html">brainpy.math.random.geometric</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.f.html">brainpy.math.random.f</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.hypergeometric.html">brainpy.math.random.hypergeometric</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.logseries.html">brainpy.math.random.logseries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.multinomial.html">brainpy.math.random.multinomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.multivariate_normal.html">brainpy.math.random.multivariate_normal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.negative_binomial.html">brainpy.math.random.negative_binomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.noncentral_chisquare.html">brainpy.math.random.noncentral_chisquare</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.noncentral_f.html">brainpy.math.random.noncentral_f</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.power.html">brainpy.math.random.power</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.rayleigh.html">brainpy.math.random.rayleigh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.triangular.html">brainpy.math.random.triangular</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.vonmises.html">brainpy.math.random.vonmises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.wald.html">brainpy.math.random.wald</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.weibull.html">brainpy.math.random.weibull</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.weibull_min.html">brainpy.math.random.weibull_min</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.zipf.html">brainpy.math.random.zipf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.maxwell.html">brainpy.math.random.maxwell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.t.html">brainpy.math.random.t</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.orthogonal.html">brainpy.math.random.orthogonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.loggamma.html">brainpy.math.random.loggamma</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.categorical.html">brainpy.math.random.categorical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.rand_like.html">brainpy.math.random.rand_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.randint_like.html">brainpy.math.random.randint_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.randn_like.html">brainpy.math.random.randn_like</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.RandomState.html">brainpy.math.random.RandomState</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.Generator.html">brainpy.math.random.Generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.random.DEFAULT.html">brainpy.math.random.DEFAULT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.cholesky.html">brainpy.math.linalg.cholesky</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.cond.html">brainpy.math.linalg.cond</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.det.html">brainpy.math.linalg.det</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.eig.html">brainpy.math.linalg.eig</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.eigh.html">brainpy.math.linalg.eigh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.eigvals.html">brainpy.math.linalg.eigvals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.eigvalsh.html">brainpy.math.linalg.eigvalsh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.inv.html">brainpy.math.linalg.inv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.svd.html">brainpy.math.linalg.svd</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.lstsq.html">brainpy.math.linalg.lstsq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.matrix_power.html">brainpy.math.linalg.matrix_power</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.matrix_rank.html">brainpy.math.linalg.matrix_rank</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.norm.html">brainpy.math.linalg.norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.pinv.html">brainpy.math.linalg.pinv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.qr.html">brainpy.math.linalg.qr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.solve.html">brainpy.math.linalg.solve</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.slogdet.html">brainpy.math.linalg.slogdet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.tensorinv.html">brainpy.math.linalg.tensorinv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.tensorsolve.html">brainpy.math.linalg.tensorsolve</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.linalg.multi_dot.html">brainpy.math.linalg.multi_dot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.fft.html">brainpy.math.fft.fft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.fft2.html">brainpy.math.fft.fft2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.fftfreq.html">brainpy.math.fft.fftfreq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.fftn.html">brainpy.math.fft.fftn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.fftshift.html">brainpy.math.fft.fftshift</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.hfft.html">brainpy.math.fft.hfft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.ifft.html">brainpy.math.fft.ifft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.ifft2.html">brainpy.math.fft.ifft2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.ifftn.html">brainpy.math.fft.ifftn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.ifftshift.html">brainpy.math.fft.ifftshift</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.ihfft.html">brainpy.math.fft.ihfft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.irfft.html">brainpy.math.fft.irfft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.irfft2.html">brainpy.math.fft.irfft2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.irfftn.html">brainpy.math.fft.irfftn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.rfft.html">brainpy.math.fft.rfft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.rfft2.html">brainpy.math.fft.rfft2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.rfftfreq.html">brainpy.math.fft.rfftfreq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.math.fft.rfftn.html">brainpy.math.fft.rfftn</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/channels.html"><code class="docutils literal notranslate"><span class="pre">brainpy.channels</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.Ion.html">brainpy.channels.Ion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IonChannel.html">brainpy.channels.IonChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.Calcium.html">brainpy.channels.Calcium</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IhChannel.html">brainpy.channels.IhChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.CalciumChannel.html">brainpy.channels.CalciumChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.SodiumChannel.html">brainpy.channels.SodiumChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.PotassiumChannel.html">brainpy.channels.PotassiumChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.LeakyChannel.html">brainpy.channels.LeakyChannel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.INa_Ba2002.html">brainpy.channels.INa_Ba2002</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.INa_TM1991.html">brainpy.channels.INa_TM1991</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.INa_HH1952.html">brainpy.channels.INa_HH1952</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKDR_Ba2002.html">brainpy.channels.IKDR_Ba2002</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IK_TM1991.html">brainpy.channels.IK_TM1991</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IK_HH1952.html">brainpy.channels.IK_HH1952</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKA1_HM1992.html">brainpy.channels.IKA1_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKA2_HM1992.html">brainpy.channels.IKA2_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKK2A_HM1992.html">brainpy.channels.IKK2A_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKK2B_HM1992.html">brainpy.channels.IKK2B_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKNI_Ya1989.html">brainpy.channels.IKNI_Ya1989</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.CalciumFixed.html">brainpy.channels.CalciumFixed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.CalciumDyna.html">brainpy.channels.CalciumDyna</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.CalciumDetailed.html">brainpy.channels.CalciumDetailed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.CalciumFirstOrder.html">brainpy.channels.CalciumFirstOrder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.ICaN_IS2008.html">brainpy.channels.ICaN_IS2008</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.ICaT_HM1992.html">brainpy.channels.ICaT_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.ICaT_HP1992.html">brainpy.channels.ICaT_HP1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.ICaHT_HM1992.html">brainpy.channels.ICaHT_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.ICaL_IS2008.html">brainpy.channels.ICaL_IS2008</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IAHP_De1994.html">brainpy.channels.IAHP_De1994</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.Ih_HM1992.html">brainpy.channels.Ih_HM1992</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.Ih_De1996.html">brainpy.channels.Ih_De1996</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IL.html">brainpy.channels.IL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.channels.IKL.html">brainpy.channels.IKL</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/layers.html"><code class="docutils literal notranslate"><span class="pre">brainpy.layers</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Layer.html">brainpy.layers.Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv1D.html">brainpy.layers.Conv1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv2D.html">brainpy.layers.Conv2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv3D.html">brainpy.layers.Conv3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.ConvTranspose1d.html">brainpy.layers.ConvTranspose1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.ConvTranspose2d.html">brainpy.layers.ConvTranspose2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.ConvTranspose3d.html">brainpy.layers.ConvTranspose3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Dropout.html">brainpy.layers.Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Activation.html">brainpy.layers.Activation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Flatten.html">brainpy.layers.Flatten</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.FunAsLayer.html">brainpy.layers.FunAsLayer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Dense.html">brainpy.layers.Dense</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Linear.html">brainpy.layers.Linear</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Identity.html">brainpy.layers.Identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.BatchNorm1D.html">brainpy.layers.BatchNorm1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.BatchNorm2D.html">brainpy.layers.BatchNorm2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.BatchNorm3D.html">brainpy.layers.BatchNorm3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.LayerNorm.html">brainpy.layers.LayerNorm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.GroupNorm.html">brainpy.layers.GroupNorm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.InstanceNorm.html">brainpy.layers.InstanceNorm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.NVAR.html">brainpy.layers.NVAR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.MaxPool.html">brainpy.layers.MaxPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.MinPool.html">brainpy.layers.MinPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AvgPool.html">brainpy.layers.AvgPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AvgPool1d.html">brainpy.layers.AvgPool1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AvgPool2d.html">brainpy.layers.AvgPool2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AvgPool3d.html">brainpy.layers.AvgPool3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.MaxPool1d.html">brainpy.layers.MaxPool1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.MaxPool2d.html">brainpy.layers.MaxPool2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.MaxPool3d.html">brainpy.layers.MaxPool3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveAvgPool1d.html">brainpy.layers.AdaptiveAvgPool1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveAvgPool2d.html">brainpy.layers.AdaptiveAvgPool2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveAvgPool3d.html">brainpy.layers.AdaptiveAvgPool3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveMaxPool1d.html">brainpy.layers.AdaptiveMaxPool1d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveMaxPool2d.html">brainpy.layers.AdaptiveMaxPool2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.AdaptiveMaxPool3d.html">brainpy.layers.AdaptiveMaxPool3d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Reservoir.html">brainpy.layers.Reservoir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.RNNCell.html">brainpy.layers.RNNCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.GRUCell.html">brainpy.layers.GRUCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.LSTMCell.html">brainpy.layers.LSTMCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv1dLSTMCell.html">brainpy.layers.Conv1dLSTMCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv2dLSTMCell.html">brainpy.layers.Conv2dLSTMCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.Conv3dLSTMCell.html">brainpy.layers.Conv3dLSTMCell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.VanillaRNN.html">brainpy.layers.VanillaRNN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.GRU.html">brainpy.layers.GRU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.layers.LSTM.html">brainpy.layers.LSTM</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/neurons.html"><code class="docutils literal notranslate"><span class="pre">brainpy.neurons</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.HH.html">brainpy.neurons.HH</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.MorrisLecar.html">brainpy.neurons.MorrisLecar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.PinskyRinzelModel.html">brainpy.neurons.PinskyRinzelModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.WangBuzsakiModel.html">brainpy.neurons.WangBuzsakiModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.FractionalNeuron.html">brainpy.neurons.FractionalNeuron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.FractionalFHR.html">brainpy.neurons.FractionalFHR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.FractionalIzhikevich.html">brainpy.neurons.FractionalIzhikevich</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.LeakyIntegrator.html">brainpy.neurons.LeakyIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.LIF.html">brainpy.neurons.LIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.ExpIF.html">brainpy.neurons.ExpIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.AdExIF.html">brainpy.neurons.AdExIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.QuaIF.html">brainpy.neurons.QuaIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.AdQuaIF.html">brainpy.neurons.AdQuaIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.GIF.html">brainpy.neurons.GIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.ALIFBellec2020.html">brainpy.neurons.ALIFBellec2020</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.Izhikevich.html">brainpy.neurons.Izhikevich</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.HindmarshRose.html">brainpy.neurons.HindmarshRose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.FHN.html">brainpy.neurons.FHN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.OUProcess.html">brainpy.neurons.OUProcess</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.InputGroup.html">brainpy.neurons.InputGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.OutputGroup.html">brainpy.neurons.OutputGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.SpikeTimeGroup.html">brainpy.neurons.SpikeTimeGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.neurons.PoissonGroup.html">brainpy.neurons.PoissonGroup</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/rates.html"><code class="docutils literal notranslate"><span class="pre">brainpy.rates</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.RateModel.html">brainpy.rates.RateModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.FHN.html">brainpy.rates.FHN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.FeedbackFHN.html">brainpy.rates.FeedbackFHN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.QIF.html">brainpy.rates.QIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.StuartLandauOscillator.html">brainpy.rates.StuartLandauOscillator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.WilsonCowanModel.html">brainpy.rates.WilsonCowanModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.rates.ThresholdLinearModel.html">brainpy.rates.ThresholdLinearModel</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/synapses.html"><code class="docutils literal notranslate"><span class="pre">brainpy.synapses</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.Delta.html">brainpy.synapses.Delta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.Exponential.html">brainpy.synapses.Exponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.DualExponential.html">brainpy.synapses.DualExponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.Alpha.html">brainpy.synapses.Alpha</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.NMDA.html">brainpy.synapses.NMDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.PoissonInput.html">brainpy.synapses.PoissonInput</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.AMPA.html">brainpy.synapses.AMPA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.GABAa.html">brainpy.synapses.GABAa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.BioNMDA.html">brainpy.synapses.BioNMDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.DelayCoupling.html">brainpy.synapses.DelayCoupling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.DiffusiveCoupling.html">brainpy.synapses.DiffusiveCoupling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.AdditiveCoupling.html">brainpy.synapses.AdditiveCoupling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synapses.GapJunction.html">brainpy.synapses.GapJunction</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/synouts.html"><code class="docutils literal notranslate"><span class="pre">brainpy.synouts</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synouts.COBA.html">brainpy.synouts.COBA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synouts.CUBA.html">brainpy.synouts.CUBA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synouts.MgBlock.html">brainpy.synouts.MgBlock</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/synplast.html"><code class="docutils literal notranslate"><span class="pre">brainpy.synplast</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synplast.STD.html">brainpy.synplast.STD</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.synplast.STP.html">brainpy.synplast.STP</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/integrators.html"><code class="docutils literal notranslate"><span class="pre">brainpy.integrators</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.ODEIntegrator.html">brainpy.integrators.ode.ODEIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.set_default_odeint.html">brainpy.integrators.ode.set_default_odeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.get_default_odeint.html">brainpy.integrators.ode.get_default_odeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.register_ode_integrator.html">brainpy.integrators.ode.register_ode_integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.get_supported_methods.html">brainpy.integrators.ode.get_supported_methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.ExplicitRKIntegrator.html">brainpy.integrators.ode.ExplicitRKIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Euler.html">brainpy.integrators.ode.Euler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.MidPoint.html">brainpy.integrators.ode.MidPoint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Heun2.html">brainpy.integrators.ode.Heun2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Ralston2.html">brainpy.integrators.ode.Ralston2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RK2.html">brainpy.integrators.ode.RK2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RK3.html">brainpy.integrators.ode.RK3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Heun3.html">brainpy.integrators.ode.Heun3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Ralston3.html">brainpy.integrators.ode.Ralston3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.SSPRK3.html">brainpy.integrators.ode.SSPRK3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RK4.html">brainpy.integrators.ode.RK4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.Ralston4.html">brainpy.integrators.ode.Ralston4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RK4Rule38.html">brainpy.integrators.ode.RK4Rule38</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.AdaptiveRKIntegrator.html">brainpy.integrators.ode.AdaptiveRKIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RKF12.html">brainpy.integrators.ode.RKF12</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.RKF45.html">brainpy.integrators.ode.RKF45</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.DormandPrince.html">brainpy.integrators.ode.DormandPrince</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.CashKarp.html">brainpy.integrators.ode.CashKarp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.BogackiShampine.html">brainpy.integrators.ode.BogackiShampine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.HeunEuler.html">brainpy.integrators.ode.HeunEuler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.ode.ExponentialEuler.html">brainpy.integrators.ode.ExponentialEuler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.SDEIntegrator.html">brainpy.integrators.sde.SDEIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.set_default_sdeint.html">brainpy.integrators.sde.set_default_sdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.get_default_sdeint.html">brainpy.integrators.sde.get_default_sdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.register_sde_integrator.html">brainpy.integrators.sde.register_sde_integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.get_supported_methods.html">brainpy.integrators.sde.get_supported_methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.Euler.html">brainpy.integrators.sde.Euler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.Heun.html">brainpy.integrators.sde.Heun</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.Milstein.html">brainpy.integrators.sde.Milstein</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.MilsteinGradFree.html">brainpy.integrators.sde.MilsteinGradFree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.ExponentialEuler.html">brainpy.integrators.sde.ExponentialEuler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.SRK1W1.html">brainpy.integrators.sde.SRK1W1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.SRK2W1.html">brainpy.integrators.sde.SRK2W1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.sde.KlPl.html">brainpy.integrators.sde.KlPl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.FDEIntegrator.html">brainpy.integrators.fde.FDEIntegrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.set_default_fdeint.html">brainpy.integrators.fde.set_default_fdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.get_default_fdeint.html">brainpy.integrators.fde.get_default_fdeint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.register_fde_integrator.html">brainpy.integrators.fde.register_fde_integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.get_supported_methods.html">brainpy.integrators.fde.get_supported_methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.CaputoEuler.html">brainpy.integrators.fde.CaputoEuler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.CaputoL1Schema.html">brainpy.integrators.fde.CaputoL1Schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.integrators.fde.GLShortMemory.html">brainpy.integrators.fde.GLShortMemory</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/analysis.html"><code class="docutils literal notranslate"><span class="pre">brainpy.analysis</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.PhasePlane1D.html">brainpy.analysis.PhasePlane1D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.PhasePlane2D.html">brainpy.analysis.PhasePlane2D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.Bifurcation1D.html">brainpy.analysis.Bifurcation1D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.Bifurcation2D.html">brainpy.analysis.Bifurcation2D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.FastSlow1D.html">brainpy.analysis.FastSlow1D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.FastSlow2D.html">brainpy.analysis.FastSlow2D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.analysis.SlowPointFinder.html">brainpy.analysis.SlowPointFinder</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/connect.html"><code class="docutils literal notranslate"><span class="pre">brainpy.connect</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.mat2coo.html">brainpy.connect.mat2coo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.mat2csc.html">brainpy.connect.mat2csc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.mat2csr.html">brainpy.connect.mat2csr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.csr2csc.html">brainpy.connect.csr2csc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.csr2mat.html">brainpy.connect.csr2mat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.csr2coo.html">brainpy.connect.csr2coo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.coo2csr.html">brainpy.connect.coo2csr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.coo2csc.html">brainpy.connect.coo2csc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.coo2mat.html">brainpy.connect.coo2mat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.Connector.html">brainpy.connect.Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.TwoEndConnector.html">brainpy.connect.TwoEndConnector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.OneEndConnector.html">brainpy.connect.OneEndConnector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.CONN_MAT.html">brainpy.connect.CONN_MAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.PRE_IDS.html">brainpy.connect.PRE_IDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.POST_IDS.html">brainpy.connect.POST_IDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.PRE2POST.html">brainpy.connect.PRE2POST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.POST2PRE.html">brainpy.connect.POST2PRE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.PRE2SYN.html">brainpy.connect.PRE2SYN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.POST2SYN.html">brainpy.connect.POST2SYN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.MatConn.html">brainpy.connect.MatConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.IJConn.html">brainpy.connect.IJConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.CSRConn.html">brainpy.connect.CSRConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.SparseMatConn.html">brainpy.connect.SparseMatConn</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.FixedProb.html">brainpy.connect.FixedProb</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.FixedPreNum.html">brainpy.connect.FixedPreNum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.FixedPostNum.html">brainpy.connect.FixedPostNum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.FixedTotalNum.html">brainpy.connect.FixedTotalNum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.GaussianProb.html">brainpy.connect.GaussianProb</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.ProbDist.html">brainpy.connect.ProbDist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.SmallWorld.html">brainpy.connect.SmallWorld</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.ScaleFreeBA.html">brainpy.connect.ScaleFreeBA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.ScaleFreeBADual.html">brainpy.connect.ScaleFreeBADual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.PowerLaw.html">brainpy.connect.PowerLaw</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.One2One.html">brainpy.connect.one2one</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.All2All.html">brainpy.connect.all2all</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.GridFour.html">brainpy.connect.GridFour</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.GridEight.html">brainpy.connect.GridEight</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.GridN.html">brainpy.connect.GridN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.grid_four.html">brainpy.connect.grid_four</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.connect.grid_eight.html">brainpy.connect.grid_eight</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/encoding.html"><code class="docutils literal notranslate"><span class="pre">brainpy.encoding</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-18"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.encoding.Encoder.html">brainpy.encoding.Encoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.encoding.LatencyEncoder.html">brainpy.encoding.LatencyEncoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.encoding.WeightedPhaseEncoder.html">brainpy.encoding.WeightedPhaseEncoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.encoding.PoissonEncoder.html">brainpy.encoding.PoissonEncoder</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/initialize.html"><code class="docutils literal notranslate"><span class="pre">brainpy.initialize</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-19"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Initializer.html">brainpy.initialize.Initializer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.InterLayerInitializer.html">brainpy.initialize.InterLayerInitializer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.IntraLayerInitializer.html">brainpy.initialize.IntraLayerInitializer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.ZeroInit.html">brainpy.initialize.ZeroInit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Constant.html">brainpy.initialize.Constant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.OneInit.html">brainpy.initialize.OneInit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Identity.html">brainpy.initialize.Identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Normal.html">brainpy.initialize.Normal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Uniform.html">brainpy.initialize.Uniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.VarianceScaling.html">brainpy.initialize.VarianceScaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.KaimingUniform.html">brainpy.initialize.KaimingUniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.KaimingNormal.html">brainpy.initialize.KaimingNormal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.XavierUniform.html">brainpy.initialize.XavierUniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.XavierNormal.html">brainpy.initialize.XavierNormal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.LecunUniform.html">brainpy.initialize.LecunUniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.LecunNormal.html">brainpy.initialize.LecunNormal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.Orthogonal.html">brainpy.initialize.Orthogonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.DeltaOrthogonal.html">brainpy.initialize.DeltaOrthogonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.GaussianDecay.html">brainpy.initialize.GaussianDecay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.initialize.DOGDecay.html">brainpy.initialize.DOGDecay</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/inputs.html"><code class="docutils literal notranslate"><span class="pre">brainpy.inputs</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-20"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.section_input.html">brainpy.inputs.section_input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.constant_input.html">brainpy.inputs.constant_input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.spike_input.html">brainpy.inputs.spike_input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.ramp_input.html">brainpy.inputs.ramp_input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.wiener_process.html">brainpy.inputs.wiener_process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.ou_process.html">brainpy.inputs.ou_process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.sinusoidal_input.html">brainpy.inputs.sinusoidal_input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.inputs.square_input.html">brainpy.inputs.square_input</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/losses.html"><code class="docutils literal notranslate"><span class="pre">brainpy.losses</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-21"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.cross_entropy_loss.html">brainpy.losses.cross_entropy_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.cross_entropy_sparse.html">brainpy.losses.cross_entropy_sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.cross_entropy_sigmoid.html">brainpy.losses.cross_entropy_sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.l1_loos.html">brainpy.losses.l1_loos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.l2_loss.html">brainpy.losses.l2_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.huber_loss.html">brainpy.losses.huber_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.mean_absolute_error.html">brainpy.losses.mean_absolute_error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.mean_squared_error.html">brainpy.losses.mean_squared_error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.mean_squared_log_error.html">brainpy.losses.mean_squared_log_error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.binary_logistic_loss.html">brainpy.losses.binary_logistic_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.multiclass_logistic_loss.html">brainpy.losses.multiclass_logistic_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.sigmoid_binary_cross_entropy.html">brainpy.losses.sigmoid_binary_cross_entropy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.softmax_cross_entropy.html">brainpy.losses.softmax_cross_entropy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.log_cosh_loss.html">brainpy.losses.log_cosh_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.ctc_loss_with_forward_probs.html">brainpy.losses.ctc_loss_with_forward_probs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.ctc_loss.html">brainpy.losses.ctc_loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.l2_norm.html">brainpy.losses.l2_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.mean_absolute.html">brainpy.losses.mean_absolute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.mean_square.html">brainpy.losses.mean_square</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.log_cosh.html">brainpy.losses.log_cosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.losses.smooth_labels.html">brainpy.losses.smooth_labels</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/measure.html"><code class="docutils literal notranslate"><span class="pre">brainpy.measure</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-22"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.cross_correlation.html">brainpy.measure.cross_correlation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.voltage_fluctuation.html">brainpy.measure.voltage_fluctuation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.matrix_correlation.html">brainpy.measure.matrix_correlation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.weighted_correlation.html">brainpy.measure.weighted_correlation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.functional_connectivity.html">brainpy.measure.functional_connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.raster_plot.html">brainpy.measure.raster_plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.firing_rate.html">brainpy.measure.firing_rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.measure.unitary_LFP.html">brainpy.measure.unitary_LFP</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/optim.html"><code class="docutils literal notranslate"><span class="pre">brainpy.optim</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-23"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Optimizer.html">brainpy.optim.Optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.SGD.html">brainpy.optim.SGD</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Momentum.html">brainpy.optim.Momentum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.MomentumNesterov.html">brainpy.optim.MomentumNesterov</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Adagrad.html">brainpy.optim.Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Adadelta.html">brainpy.optim.Adadelta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.RMSProp.html">brainpy.optim.RMSProp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Adam.html">brainpy.optim.Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.LARS.html">brainpy.optim.LARS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Adan.html">brainpy.optim.Adan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.AdamW.html">brainpy.optim.AdamW</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.make_schedule.html">brainpy.optim.make_schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Scheduler.html">brainpy.optim.Scheduler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.Constant.html">brainpy.optim.Constant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.StepLR.html">brainpy.optim.StepLR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.MultiStepLR.html">brainpy.optim.MultiStepLR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.CosineAnnealingLR.html">brainpy.optim.CosineAnnealingLR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.CosineAnnealingWarmRestarts.html">brainpy.optim.CosineAnnealingWarmRestarts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.ExponentialLR.html">brainpy.optim.ExponentialLR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.ExponentialDecay.html">brainpy.optim.ExponentialDecay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.InverseTimeDecay.html">brainpy.optim.InverseTimeDecay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.PolynomialDecay.html">brainpy.optim.PolynomialDecay</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.optim.PiecewiseConstant.html">brainpy.optim.PiecewiseConstant</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apis/auto/running.html"><code class="docutils literal notranslate"><span class="pre">brainpy.running</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-24"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.jax_vectorize_map.html">brainpy.running.jax_vectorize_map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.jax_parallelize_map.html">brainpy.running.jax_parallelize_map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.process_pool.html">brainpy.running.process_pool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.process_pool_lock.html">brainpy.running.process_pool_lock</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.cpu_ordered_parallel.html">brainpy.running.cpu_ordered_parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../apis/auto/generated/brainpy.running.cpu_unordered_parallel.html">brainpy.running.cpu_unordered_parallel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../apis/auto/changelog.html">Release notes (brainpy)</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for numpy.lib.function_base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.core.numeric</span> <span class="k">as</span> <span class="nn">_nx</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">transpose</span>
<span class="kn">from</span> <span class="nn">numpy.core.numeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ones</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
    <span class="n">ndarray</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">absolute</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">frompyfunc</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">less_equal</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
    <span class="n">mod</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">not_equal</span><span class="p">,</span> <span class="n">subtract</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.fromnumeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ravel</span><span class="p">,</span> <span class="n">nonzero</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">sum</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.numerictypes</span> <span class="kn">import</span> <span class="n">typecodes</span>
<span class="kn">from</span> <span class="nn">numpy.core.overrides</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">overrides</span>
<span class="kn">from</span> <span class="nn">numpy.core.function_base</span> <span class="kn">import</span> <span class="n">add_newdoc</span>
<span class="kn">from</span> <span class="nn">numpy.lib.twodim_base</span> <span class="kn">import</span> <span class="n">diag</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_insert</span><span class="p">,</span> <span class="n">add_docstring</span><span class="p">,</span> <span class="n">bincount</span><span class="p">,</span> <span class="n">normalize_axis_index</span><span class="p">,</span> <span class="n">_monotonicity</span><span class="p">,</span>
    <span class="n">interp</span> <span class="k">as</span> <span class="n">compiled_interp</span><span class="p">,</span> <span class="n">interp_complex</span> <span class="k">as</span> <span class="n">compiled_interp_complex</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="n">_add_newdoc_ufunc</span> <span class="k">as</span> <span class="n">add_newdoc_ufunc</span>

<span class="kn">import</span> <span class="nn">builtins</span>

<span class="c1"># needed in this module for compatibility</span>
<span class="kn">from</span> <span class="nn">numpy.lib.histograms</span> <span class="kn">import</span> <span class="n">histogram</span><span class="p">,</span> <span class="n">histogramdd</span>  <span class="c1"># noqa: F401</span>


<span class="n">array_function_dispatch</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">overrides</span><span class="o">.</span><span class="n">array_function_dispatch</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;select&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">,</span> <span class="s1">&#39;trim_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="s1">&#39;iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;percentile&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;unwrap&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_complex&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;flip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rot90&#39;</span><span class="p">,</span> <span class="s1">&#39;extract&#39;</span><span class="p">,</span> <span class="s1">&#39;place&#39;</span><span class="p">,</span> <span class="s1">&#39;vectorize&#39;</span><span class="p">,</span> <span class="s1">&#39;asarray_chkfinite&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bincount&#39;</span><span class="p">,</span> <span class="s1">&#39;digitize&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;corrcoef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;msort&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blackman&#39;</span><span class="p">,</span> <span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="s1">&#39;i0&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc&#39;</span><span class="p">,</span> <span class="s1">&#39;add_docstring&#39;</span><span class="p">,</span>
    <span class="s1">&#39;meshgrid&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;insert&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc_ufunc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;quantile&#39;</span>
    <span class="p">]</span>

<span class="c1"># _QuantileMethods is a dictionary listing all the supported methods to</span>
<span class="c1"># compute quantile/percentile.</span>
<span class="c1">#</span>
<span class="c1"># Below virtual_index refer to the index of the element where the percentile</span>
<span class="c1"># would be found in the sorted sample.</span>
<span class="c1"># When the sample contains exactly the percentile wanted, the virtual_index is</span>
<span class="c1"># an integer to the index of this element.</span>
<span class="c1"># When the percentile wanted is in between two elements, the virtual_index</span>
<span class="c1"># is made of a integer part (a.k.a &#39;i&#39; or &#39;left&#39;) and a fractional part</span>
<span class="c1"># (a.k.a &#39;g&#39; or &#39;gamma&#39;)</span>
<span class="c1">#</span>
<span class="c1"># Each method in _QuantileMethods has two properties</span>
<span class="c1"># get_virtual_index : Callable</span>
<span class="c1">#   The function used to compute the virtual_index.</span>
<span class="c1"># fix_gamma : Callable</span>
<span class="c1">#   A function used for discret methods to force the index to a specific value.</span>
<span class="n">_QuantileMethods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># --- HYNDMAN and FAN METHODS</span>
    <span class="c1"># Discrete methods</span>
    <span class="n">inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">_inverted_cdf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>  <span class="c1"># should never be called</span>
    <span class="p">),</span>
    <span class="n">averaged_inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">_get_gamma_mask</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">default_value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">conditioned_value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">closest_observation</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">_closest_observation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span>
                                                                    <span class="n">quantiles</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>  <span class="c1"># should never be called</span>
    <span class="p">),</span>
    <span class="c1"># Continuous methods</span>
    <span class="n">interpolated_inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">hazen</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">weibull</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="c1"># Default method.</span>
    <span class="c1"># To avoid some rounding issues, `(n-1) * quantiles` is preferred to</span>
    <span class="c1"># `_compute_virtual_index(n, quantiles, 1, 1)`.</span>
    <span class="c1"># They are mathematically equivalent.</span>
    <span class="n">linear</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">,</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">median_unbiased</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">normal_unbiased</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="c1"># --- OTHER METHODS</span>
    <span class="n">lower</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">),</span>
    <span class="n">higher</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">),</span>
    <span class="n">midpoint</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">_get_gamma_mask</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">default_value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">conditioned_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">index</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">nearest</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">))</span>


<span class="k">def</span> <span class="nf">_rot90_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_rot90_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate an array by 90 degrees in the plane specified by axes.</span>

<span class="sd">    Rotation direction is from the first towards the second axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Array of two or more dimensions.</span>
<span class="sd">    k : integer</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>
<span class="sd">    axes : (2,) array_like</span>
<span class="sd">        The array is rotated in the plane defined by the axes.</span>
<span class="sd">        Axes must be different.</span>

<span class="sd">        .. versionadded:: 1.12.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        A rotated view of `m`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flip : Reverse the order of elements in an array along the given axis.</span>
<span class="sd">    fliplr : Flip an array horizontally.</span>
<span class="sd">    flipud : Flip an array vertically.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``rot90(m, k=1, axes=(1,0))``  is the reverse of</span>
<span class="sd">    ``rot90(m, k=1, axes=(0,1))``</span>

<span class="sd">    ``rot90(m, k=1, axes=(1,0))`` is equivalent to</span>
<span class="sd">    ``rot90(m, k=-1, axes=(0,1))``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m)</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 2)</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 1, (1,2))</span>
<span class="sd">    array([[[1, 3],</span>
<span class="sd">            [0, 2]],</span>
<span class="sd">           [[5, 7],</span>
<span class="sd">            [4, 6]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) must be 2.&quot;</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">absolute</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
        <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes=</span><span class="si">{}</span><span class="s2"> out of range for array of ndim=</span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="n">k</span> <span class="o">%=</span> <span class="mi">4</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">axes_list</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axes_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># k == 3</span>
        <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes_list</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_flip_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_flip_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the order of elements in an array along the given axis.</span>

<span class="sd">    The shape of the array is preserved, but the elements are reordered.</span>

<span class="sd">    .. versionadded:: 1.12.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">         Axis or axes along which to flip over. The default,</span>
<span class="sd">         axis=None, will flip over all of the axes of the input array.</span>
<span class="sd">         If axis is negative it counts from the last to the first axis.</span>

<span class="sd">         If axis is a tuple of ints, flipping is performed on all of the axes</span>
<span class="sd">         specified in the tuple.</span>

<span class="sd">         .. versionchanged:: 1.15.0</span>
<span class="sd">            None and tuples of axes are supported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        A view of `m` with the entries of axis reversed.  Since a view is</span>
<span class="sd">        returned, this operation is done in constant time.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flipud : Flip an array vertically (axis=0).</span>
<span class="sd">    fliplr : Flip an array horizontally (axis=1).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    flip(m, 0) is equivalent to flipud(m).</span>

<span class="sd">    flip(m, 1) is equivalent to fliplr(m).</span>

<span class="sd">    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.</span>

<span class="sd">    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all</span>
<span class="sd">    positions.</span>

<span class="sd">    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at</span>
<span class="sd">    position 0 and position 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 0)</span>
<span class="sd">    array([[[4, 5],</span>
<span class="sd">            [6, 7]],</span>
<span class="sd">           [[0, 1],</span>
<span class="sd">            [2, 3]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 1)</span>
<span class="sd">    array([[[2, 3],</span>
<span class="sd">            [0, 1]],</span>
<span class="sd">           [[6, 7],</span>
<span class="sd">            [4, 5]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A)</span>
<span class="sd">    array([[[7, 6],</span>
<span class="sd">            [5, 4]],</span>
<span class="sd">           [[3, 2],</span>
<span class="sd">            [1, 0]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, (0, 2))</span>
<span class="sd">    array([[[5, 4],</span>
<span class="sd">            [7, 6]],</span>
<span class="sd">           [[1, 0],</span>
<span class="sd">            [3, 2]]])</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.randn(3,4,5)</span>
<span class="sd">    &gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:]]</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether or not an object can be iterated over.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : object</span>
<span class="sd">      Input object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : bool</span>
<span class="sd">      Return ``True`` if the object has an iterator method or is a</span>
<span class="sd">      sequence and ``False`` otherwise.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.iterable([1, 2, 3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.iterable(2)</span>
<span class="sd">    False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In most cases, the results of ``np.iterable(obj)`` are consistent with</span>
<span class="sd">    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is</span>
<span class="sd">    the treatment of 0-dimensional arrays::</span>

<span class="sd">        &gt;&gt;&gt; from collections.abc import Iterable</span>
<span class="sd">        &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional numpy array</span>
<span class="sd">        &gt;&gt;&gt; isinstance(a, Iterable)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.iterable(a)</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_average_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_average_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted average along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing data to be averaged. If `a` is not an array, a</span>
<span class="sd">        conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which to average `a`.  The default,</span>
<span class="sd">        axis=None, will average over all of the elements of the input array.</span>
<span class="sd">        If axis is negative it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If axis is a tuple of ints, averaging is performed on all of the axes</span>
<span class="sd">        specified in the tuple instead of a single axis or all the axes as</span>
<span class="sd">        before.</span>
<span class="sd">    weights : array_like, optional</span>
<span class="sd">        An array of weights associated with the values in `a`. Each value in</span>
<span class="sd">        `a` contributes to the average according to its associated weight.</span>
<span class="sd">        The weights array can either be 1-D (in which case its length must be</span>
<span class="sd">        the size of `a` along the given axis) or of the same shape as `a`.</span>
<span class="sd">        If `weights=None`, then all data in `a` are assumed to have a</span>
<span class="sd">        weight equal to one.  The 1-D calculation is::</span>

<span class="sd">            avg = sum(a * weights) / sum(weights)</span>

<span class="sd">        The only constraint on `weights` is that `sum(weights)` must not be 0.</span>
<span class="sd">    returned : bool, optional</span>
<span class="sd">        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)</span>
<span class="sd">        is returned, otherwise only the average is returned.</span>
<span class="sd">        If `weights=None`, `sum_of_weights` is equivalent to the number of</span>
<span class="sd">        elements over which the average is taken.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        *Note:* `keepdims` will not work with instances of `numpy.matrix`</span>
<span class="sd">        or other classes whose methods do not support `keepdims`.</span>

<span class="sd">        .. versionadded:: 1.23.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    retval, [sum_of_weights] : array_type or double</span>
<span class="sd">        Return the average along the specified axis. When `returned` is `True`,</span>
<span class="sd">        return a tuple with the average as the first element and the sum</span>
<span class="sd">        of the weights as the second element. `sum_of_weights` is of the</span>
<span class="sd">        same type as `retval`. The result dtype follows a genereal pattern.</span>
<span class="sd">        If `weights` is None, the result dtype will be that of `a` , or ``float64``</span>
<span class="sd">        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-</span>
<span class="sd">        integral, the result type will be the type of lowest precision capable of</span>
<span class="sd">        representing values of both `a` and `weights`. If `a` happens to be</span>
<span class="sd">        integral, the previous rules still applies but the result dtype will</span>
<span class="sd">        at least be ``float64``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        When all weights along axis are zero. See `numpy.ma.average` for a</span>
<span class="sd">        version robust to this type of error.</span>
<span class="sd">    TypeError</span>
<span class="sd">        When the length of 1D `weights` is not the same as the shape of `a`</span>
<span class="sd">        along axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>

<span class="sd">    ma.average : average for masked arrays -- useful if your data contains</span>
<span class="sd">                 &quot;missing&quot; values</span>
<span class="sd">    numpy.result_type : Returns the type that results from applying the</span>
<span class="sd">                        numpy type promotion rules to the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = np.arange(1, 5)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))</span>
<span class="sd">    4.0</span>

<span class="sd">    &gt;&gt;&gt; data = np.arange(6).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])</span>
<span class="sd">    array([0.75, 2.75, 4.75])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: Axis must be specified when shapes of a and weights differ.</span>

<span class="sd">    &gt;&gt;&gt; a = np.ones(5, dtype=np.float128)</span>
<span class="sd">    &gt;&gt;&gt; w = np.ones(5, dtype=np.complex64)</span>
<span class="sd">    &gt;&gt;&gt; avg = np.average(a, weights=w)</span>
<span class="sd">    &gt;&gt;&gt; print(avg.dtype)</span>
<span class="sd">    complex256</span>

<span class="sd">    With ``keepdims=True``, the following result has shape (3, 1).</span>

<span class="sd">    &gt;&gt;&gt; np.average(data, axis=1, keepdims=True)</span>
<span class="sd">    array([[0.5],</span>
<span class="sd">           [2.5],</span>
<span class="sd">           [4.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># Don&#39;t pass on the keepdims argument if one wasn&#39;t given.</span>
        <span class="n">keepdims_kw</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keepdims_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">avg</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Axis must be specified when shapes of a and weights &quot;</span>
                    <span class="s2">&quot;differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;1D weights expected when shapes of a and weights differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of weights not compatible with specified axis.&quot;</span><span class="p">)</span>

            <span class="c1"># setup wgt to broadcast along axis</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">wgt</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">scl</span> <span class="o">=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">scl</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="s2">&quot;Weights sum to zero, can&#39;t be normalized&quot;</span><span class="p">)</span>

        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span> <span class="o">/</span> <span class="n">scl</span>

    <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">scl</span><span class="p">,</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">scl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avg</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the input to an array, checking for NaNs or Infs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.  This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists and ndarrays.  Success requires no NaNs or Infs.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.</span>
<span class="sd">        &#39;C&#39; row-major (C-style),</span>
<span class="sd">        &#39;F&#39; column-major (Fortran-style) memory representation.</span>
<span class="sd">        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise</span>
<span class="sd">        &#39;K&#39; (keep) preserve input order</span>
<span class="sd">        Defaults to &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array interpretation of `a`.  No copy is performed if the input</span>
<span class="sd">        is already an ndarray.  If `a` is a subclass of ndarray, a base</span>
<span class="sd">        class ndarray is returned.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Create and array.</span>
<span class="sd">    asanyarray : Similar function which passes through subclasses.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfarray : Convert input to a floating point ndarray.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    fromiter : Create an array from an iterator.</span>
<span class="sd">    fromfunction : Construct an array by executing a function on grid</span>
<span class="sd">                   positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert a list into an array.  If all elements are finite</span>
<span class="sd">    ``asarray_chkfinite`` is identical to ``asarray``.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)</span>
<span class="sd">    array([1., 2.])</span>

<span class="sd">    Raises ValueError if array_like contains Nans or Infs.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2, np.inf]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     np.asarray_chkfinite(a)</span>
<span class="sd">    ... except ValueError:</span>
<span class="sd">    ...     print(&#39;ValueError&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;AllFloat&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;array must not contain infs or NaNs&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_piecewise_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">x</span>
    <span class="c1"># support the undocumented behavior of allowing scalars</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">condlist</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_piecewise_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a piecewise-defined function.</span>

<span class="sd">    Given a set of conditions and corresponding functions, evaluate each</span>
<span class="sd">    function on the input data wherever its condition is true.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray or scalar</span>
<span class="sd">        The input domain.</span>
<span class="sd">    condlist : list of bool arrays or bool scalars</span>
<span class="sd">        Each boolean array corresponds to a function in `funclist`.  Wherever</span>
<span class="sd">        `condlist[i]` is True, `funclist[i](x)` is used as the output value.</span>

<span class="sd">        Each boolean array in `condlist` selects a piece of `x`,</span>
<span class="sd">        and should therefore be of the same shape as `x`.</span>

<span class="sd">        The length of `condlist` must correspond to that of `funclist`.</span>
<span class="sd">        If one extra function is given, i.e. if</span>
<span class="sd">        ``len(funclist) == len(condlist) + 1``, then that extra function</span>
<span class="sd">        is the default value, used wherever all conditions are false.</span>
<span class="sd">    funclist : list of callables, f(x,*args,**kw), or scalars</span>
<span class="sd">        Each function is evaluated over `x` wherever its corresponding</span>
<span class="sd">        condition is True.  It should take a 1d array as input and give an 1d</span>
<span class="sd">        array or a scalar value as output.  If, instead of a callable,</span>
<span class="sd">        a scalar is provided then a constant function (``lambda x: scalar``) is</span>
<span class="sd">        assumed.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Any further arguments given to `piecewise` are passed to the functions</span>
<span class="sd">        upon execution, i.e., if called ``piecewise(..., ..., 1, &#39;a&#39;)``, then</span>
<span class="sd">        each function is called as ``f(x, 1, &#39;a&#39;)``.</span>
<span class="sd">    kw : dict, optional</span>
<span class="sd">        Keyword arguments used in calling `piecewise` are passed to the</span>
<span class="sd">        functions upon execution, i.e., if called</span>
<span class="sd">        ``piecewise(..., ..., alpha=1)``, then each function is called as</span>
<span class="sd">        ``f(x, alpha=1)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The output is the same shape and type as x and is found by</span>
<span class="sd">        calling the functions in `funclist` on the appropriate portions of `x`,</span>
<span class="sd">        as defined by the boolean arrays in `condlist`.  Portions not covered</span>
<span class="sd">        by any condition have a default value of 0.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose, select, where</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is similar to choose or select, except that functions are</span>
<span class="sd">    evaluated on elements of `x` that satisfy the corresponding condition from</span>
<span class="sd">    `condlist`.</span>

<span class="sd">    The result is::</span>

<span class="sd">            |--</span>
<span class="sd">            |funclist[0](x[condlist[0]])</span>
<span class="sd">      out = |funclist[1](x[condlist[1]])</span>
<span class="sd">            |...</span>
<span class="sd">            |funclist[n2](x[condlist[n2]])</span>
<span class="sd">            |--</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define the sigma function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])</span>
<span class="sd">    array([-1., -1., -1.,  1.,  1.,  1.])</span>

<span class="sd">    Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for</span>
<span class="sd">    ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])</span>
<span class="sd">    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>

<span class="sd">    Apply the same function to a scalar value.</span>

<span class="sd">    &gt;&gt;&gt; y = -2</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])</span>
<span class="sd">    array(2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>

    <span class="c1"># undocumented: single condition is promoted to a list of one condition</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">condlist</span><span class="p">]</span>

    <span class="n">condlist</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># compute the &quot;otherwise&quot; condition.</span>
        <span class="n">condelse</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">condlist</span><span class="p">,</span> <span class="n">condelse</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;with </span><span class="si">{}</span><span class="s2"> condition(s), either </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2"> functions are expected&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_select_dispatcher</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="n">condlist</span>
    <span class="k">yield from</span> <span class="n">choicelist</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_select_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array drawn from elements in choicelist, depending on conditions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condlist : list of bool ndarrays</span>
<span class="sd">        The list of conditions which determine from which array in `choicelist`</span>
<span class="sd">        the output elements are taken. When multiple conditions are satisfied,</span>
<span class="sd">        the first one encountered in `condlist` is used.</span>
<span class="sd">    choicelist : list of ndarrays</span>
<span class="sd">        The list of arrays from which the output elements are taken. It has</span>
<span class="sd">        to be of the same length as `condlist`.</span>
<span class="sd">    default : scalar, optional</span>
<span class="sd">        The element inserted in `output` when all conditions evaluate to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        The output at position m is the m-th element of the array in</span>
<span class="sd">        `choicelist` where the m-th element of the corresponding array in</span>
<span class="sd">        `condlist` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    where : Return elements from one of two arrays depending on condition.</span>
<span class="sd">    take, choose, compress, diag, diagonal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 42)</span>
<span class="sd">    array([ 0,  1,  2, 42, 16, 25])</span>

<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 55)</span>
<span class="sd">    array([ 0,  1,  2,  3,  4, 25])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the size of condlist and choicelist are the same, or abort.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;list of cases must be same length as list of conditions&#39;</span><span class="p">)</span>

    <span class="c1"># Now that the dtype is known, handle the deprecated select([], []) case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;select with an empty condition list is not possible&quot;</span><span class="p">)</span>

    <span class="n">choicelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choicelist</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">intermediate_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Choicelist elements do not have a common dtype: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
    <span class="n">default_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
    <span class="n">choicelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_array</span><span class="p">)</span>

    <span class="c1"># need to get the result type before broadcasting for correct scalar</span>
    <span class="c1"># behaviour</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">intermediate_dtype</span><span class="p">,</span> <span class="n">default_array</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Choicelists and default value do not have a common dtype: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="c1"># Convert conditions to arrays and broadcast conditions and choices</span>
    <span class="c1"># as the shape is needed for the result. Doing it separately optimizes</span>
    <span class="c1"># for example when all choices are scalars.</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="c1"># If cond array is not an ndarray in boolean format or scalar bool, abort.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;invalid entry </span><span class="si">{}</span><span class="s1"> in condlist: should be boolean ndarray&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This may be common, so avoid the call.</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Use np.copyto to burn each choicelist array onto result, using the</span>
    <span class="c1"># corresponding condlist as a boolean mask. This is done in reverse</span>
    <span class="c1"># order since the first choice should take precedence.</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">choice</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">choicelist</span><span class="p">,</span> <span class="n">condlist</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_copy_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_copy_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array copy of the given object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        Controls the memory layout of the copy. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible. (Note that this function and :meth:`ndarray.copy` are very</span>
<span class="sd">        similar, but have different default values for their order=</span>
<span class="sd">        arguments.)</span>
<span class="sd">    subok : bool, optional</span>
<span class="sd">        If True, then sub-classes will be passed-through, otherwise the</span>
<span class="sd">        returned array will be forced to be a base-class array (defaults to False).</span>

<span class="sd">        .. versionadded:: 1.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Array interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.copy : Preferred method for creating an array copy</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is equivalent to:</span>

<span class="sd">    &gt;&gt;&gt; np.array(a, copy=True)  #doctest: +SKIP</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an array x, with a reference y and a copy z:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x</span>
<span class="sd">    &gt;&gt;&gt; z = np.copy(x)</span>

<span class="sd">    Note that, when we modify x, y changes, but not z:</span>

<span class="sd">    &gt;&gt;&gt; x[0] = 10</span>
<span class="sd">    &gt;&gt;&gt; x[0] == y[0]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x[0] == z[0]</span>
<span class="sd">    False</span>

<span class="sd">    Note that, np.copy clears previously set WRITEABLE=False flag.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; a.flags[&quot;WRITEABLE&quot;] = False</span>
<span class="sd">    &gt;&gt;&gt; b = np.copy(a)</span>
<span class="sd">    &gt;&gt;&gt; b.flags[&quot;WRITEABLE&quot;]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b[0] = 3</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([3, 2, 3])</span>

<span class="sd">    Note that np.copy is a shallow copy and will not copy object</span>
<span class="sd">    elements within arrays. This is mainly important for arrays</span>
<span class="sd">    containing Python objects. The new array will contain the</span>
<span class="sd">    same object which may lead to surprises if that object can</span>
<span class="sd">    be modified (is mutable):</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; b = np.copy(a)</span>
<span class="sd">    &gt;&gt;&gt; b[2][0] = 10</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>

<span class="sd">    To ensure all elements within an ``object`` array are copied,</span>
<span class="sd">    use `copy.deepcopy`:</span>

<span class="sd">    &gt;&gt;&gt; import copy</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; c = copy.deepcopy(a)</span>
<span class="sd">    &gt;&gt;&gt; c[2][0] = 10</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, &#39;m&#39;, list([2, 3, 4])], dtype=object)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Basic operations</span>


<span class="k">def</span> <span class="nf">_gradient_dispatcher</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">f</span>
    <span class="k">yield from</span> <span class="n">varargs</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_gradient_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the gradient of an N-dimensional array.</span>

<span class="sd">    The gradient is computed using second order accurate central differences</span>
<span class="sd">    in the interior points and either first or second order accurate one-sides</span>
<span class="sd">    (forward or backwards) differences at the boundaries.</span>
<span class="sd">    The returned gradient hence has the same shape as the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : array_like</span>
<span class="sd">        An N-dimensional array containing samples of a scalar function.</span>
<span class="sd">    varargs : list of scalar or array, optional</span>
<span class="sd">        Spacing between f values. Default unitary spacing for all dimensions.</span>
<span class="sd">        Spacing can be specified using:</span>

<span class="sd">        1. single scalar to specify a sample distance for all dimensions.</span>
<span class="sd">        2. N scalars to specify a constant sample distance for each dimension.</span>
<span class="sd">           i.e. `dx`, `dy`, `dz`, ...</span>
<span class="sd">        3. N arrays to specify the coordinates of the values along each</span>
<span class="sd">           dimension of F. The length of the array must match the size of</span>
<span class="sd">           the corresponding dimension</span>
<span class="sd">        4. Any combination of N scalars/arrays with the meaning of 2. and 3.</span>

<span class="sd">        If `axis` is given, the number of varargs must equal the number of axes.</span>
<span class="sd">        Default: 1.</span>

<span class="sd">    edge_order : {1, 2}, optional</span>
<span class="sd">        Gradient is calculated using N-th order accurate differences</span>
<span class="sd">        at the boundaries. Default: 1.</span>

<span class="sd">        .. versionadded:: 1.9.1</span>

<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Gradient is calculated only along the given axis or axes</span>
<span class="sd">        The default (axis = None) is to calculate the gradient for all the axes</span>
<span class="sd">        of the input array. axis may be negative, in which case it counts from</span>
<span class="sd">        the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.11.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gradient : ndarray or list of ndarray</span>
<span class="sd">        A list of ndarrays (or a single ndarray if there is only one dimension)</span>
<span class="sd">        corresponding to the derivatives of f with respect to each dimension.</span>
<span class="sd">        Each derivative has the same shape as f.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f)</span>
<span class="sd">    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, 2)</span>
<span class="sd">    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>

<span class="sd">    Spacing can be also specified with an array that represents the coordinates</span>
<span class="sd">    of the values F along the dimensions.</span>
<span class="sd">    For instance a uniform spacing:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(f.size)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, x)</span>
<span class="sd">    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>

<span class="sd">    Or a non uniform one:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, x)</span>
<span class="sd">    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>

<span class="sd">    For two dimensional arrays, the return will be two arrays ordered by</span>
<span class="sd">    axis. In this example the first array stands for the gradient in</span>
<span class="sd">    rows and the second one in columns direction:</span>

<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))</span>
<span class="sd">    [array([[ 2.,  2., -1.],</span>
<span class="sd">           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],</span>
<span class="sd">           [1. , 1. , 1. ]])]</span>

<span class="sd">    In this example the spacing is also specified:</span>
<span class="sd">    uniform for axis=0 and non uniform for axis=1</span>

<span class="sd">    &gt;&gt;&gt; dx = 2.</span>
<span class="sd">    &gt;&gt;&gt; y = [1., 1.5, 3.5]</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)</span>
<span class="sd">    [array([[ 1. ,  1. , -0.5],</span>
<span class="sd">           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],</span>
<span class="sd">           [2. , 1.7, 0.5]])]</span>

<span class="sd">    It is possible to specify how boundaries are treated using `edge_order`</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; f = x**2</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, edge_order=1)</span>
<span class="sd">    array([1.,  2.,  4.,  6.,  7.])</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, edge_order=2)</span>
<span class="sd">    array([0., 2., 4., 6., 8.])</span>

<span class="sd">    The `axis` keyword can be used to specify a subset of axes of which the</span>
<span class="sd">    gradient is calculated</span>

<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)</span>
<span class="sd">    array([[ 2.,  2., -1.],</span>
<span class="sd">           [ 2.,  2., -1.]])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous</span>
<span class="sd">    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we</span>
<span class="sd">    minimize the &quot;consistency error&quot; :math:`\\eta_{i}` between the true gradient</span>
<span class="sd">    and its estimate from a linear combination of the neighboring grid-points:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\eta_{i} = f_{i}^{\\left(1\\right)} -</span>
<span class="sd">                    \\left[ \\alpha f\\left(x_{i}\\right) +</span>
<span class="sd">                            \\beta f\\left(x_{i} + h_{d}\\right) +</span>
<span class="sd">                            \\gamma f\\left(x_{i}-h_{s}\\right)</span>
<span class="sd">                    \\right]</span>

<span class="sd">    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`</span>
<span class="sd">    with their Taylor series expansion, this translates into solving</span>
<span class="sd">    the following the linear system:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\left\\{</span>
<span class="sd">            \\begin{array}{r}</span>
<span class="sd">                \\alpha+\\beta+\\gamma=0 \\\\</span>
<span class="sd">                \\beta h_{d}-\\gamma h_{s}=1 \\\\</span>
<span class="sd">                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0</span>
<span class="sd">            \\end{array}</span>
<span class="sd">        \\right.</span>

<span class="sd">    The resulting approximation of :math:`f_{i}^{(1)}` is the following:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\hat f_{i}^{(1)} =</span>
<span class="sd">            \\frac{</span>
<span class="sd">                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)</span>
<span class="sd">                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)</span>
<span class="sd">                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}</span>
<span class="sd">                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}</span>
<span class="sd">            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}</span>
<span class="sd">                                + h_{s}h_{d}^{2}}{h_{d}</span>
<span class="sd">                                + h_{s}}\\right)</span>

<span class="sd">    It is worth noting that if :math:`h_{s}=h_{d}`</span>
<span class="sd">    (i.e., data are evenly spaced)</span>
<span class="sd">    we find the standard second order approximation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\hat f_{i}^{(1)}=</span>
<span class="sd">            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}</span>
<span class="sd">            + \\mathcal{O}\\left(h^{2}\\right)</span>

<span class="sd">    With a similar procedure the forward/backward approximations used for</span>
<span class="sd">    boundaries can be derived.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics</span>
<span class="sd">            (Texts in Applied Mathematics). New York: Springer.</span>
<span class="sd">    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations</span>
<span class="sd">            in Geophysical Fluid Dynamics. New York: Springer.</span>
<span class="sd">    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on</span>
<span class="sd">            Arbitrarily Spaced Grids,</span>
<span class="sd">            Mathematics of Computation 51, no. 184 : 699-706.</span>
<span class="sd">            `PDF &lt;http://www.ams.org/journals/mcom/1988-51-184/</span>
<span class="sd">            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ndim</span>  <span class="c1"># number of dimensions</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">len_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no spacing argument - use 1 in all axes</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len_axes</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">varargs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># single scalar for all axes</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">varargs</span> <span class="o">*</span> <span class="n">len_axes</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">len_axes</span><span class="p">:</span>
        <span class="c1"># scalar or 1d array for each axis</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">distances</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">distances</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;distances must be either scalars or 1d&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;when 1d, distances must match &quot;</span>
                                 <span class="s2">&quot;the length of the corresponding dimension&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="c1"># Convert numpy integer types to float64 to avoid modular</span>
                <span class="c1"># arithmetic in np.diff(distances).</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">diffx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="c1"># if distances are constant reduce to the scalar case</span>
            <span class="c1"># since it brings a consistent speedup</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">diffx</span> <span class="o">==</span> <span class="n">diffx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">diffx</span> <span class="o">=</span> <span class="n">diffx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;invalid number of arguments&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge_order</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;edge_order&#39; greater than 2 not supported&quot;</span><span class="p">)</span>

    <span class="c1"># use central differences on interior and one-sided differences on the</span>
    <span class="c1"># endpoints. This preserves second order-accuracy over the full domain.</span>

    <span class="n">outvals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># create slice objects --- initially all are [:, :, ..., :]</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice3</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice4</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>

    <span class="n">otype</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">otype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">:</span>
        <span class="c1"># the timedelta dtype with the same unit information</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">otype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;timedelta&#39;</span><span class="p">))</span>
        <span class="c1"># view as timedelta to allow addition</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">otype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">otype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">otype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># All other types convert to floating point.</span>
        <span class="c1"># First check if f is a numpy integer type; if so, convert f to float64</span>
        <span class="c1"># to avoid modular arithmetic when computing the changes in f.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">otype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ax_dx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape of array too small to calculate a numerical gradient, &quot;</span>
                <span class="s2">&quot;at least (edge_order + 1) elements are required.&quot;</span><span class="p">)</span>
        <span class="c1"># result allocation</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otype</span><span class="p">)</span>

        <span class="c1"># spacing for the current axis</span>
        <span class="n">uniform_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">ax_dx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Numerical differentiation: 2nd order interior</span>
        <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">ax_dx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dx2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">-</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dx1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># fix the shape for broadcasting</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
            <span class="c1"># 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

        <span class="c1"># Numerical differentiation: 1st order edges</span>
        <span class="k">if</span> <span class="n">edge_order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">dx_0</span> <span class="o">=</span> <span class="n">ax_dx</span> <span class="k">if</span> <span class="n">uniform_spacing</span> <span class="k">else</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)])</span> <span class="o">/</span> <span class="n">dx_0</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">dx_n</span> <span class="o">=</span> <span class="n">ax_dx</span> <span class="k">if</span> <span class="n">uniform_spacing</span> <span class="k">else</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)])</span> <span class="o">/</span> <span class="n">dx_n</span>

        <span class="c1"># Numerical differentiation: 2nd order edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">b</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dx1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">+</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dx2</span> <span class="o">+</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

        <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="c1"># reset the slice object in this dimension to &quot;:&quot;</span>
        <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">len_axes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span>


<span class="k">def</span> <span class="nf">_diff_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">prepend</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_diff_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the n-th discrete difference along the given axis.</span>

<span class="sd">    The first difference is given by ``out[i] = a[i+1] - a[i]`` along</span>
<span class="sd">    the given axis, higher differences are calculated by using `diff`</span>
<span class="sd">    recursively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The number of times values are differenced. If zero, the input</span>
<span class="sd">        is returned as-is.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the difference is taken, default is the</span>
<span class="sd">        last axis.</span>
<span class="sd">    prepend, append : array_like, optional</span>
<span class="sd">        Values to prepend or append to `a` along axis prior to</span>
<span class="sd">        performing the difference.  Scalar values are expanded to</span>
<span class="sd">        arrays with length 1 in the direction of axis and the shape</span>
<span class="sd">        of the input array in along all other axes.  Otherwise the</span>
<span class="sd">        dimension and shape must match `a` except along axis.</span>

<span class="sd">        .. versionadded:: 1.16.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff : ndarray</span>
<span class="sd">        The n-th differences. The shape of the output is the same as `a`</span>
<span class="sd">        except along `axis` where the dimension is smaller by `n`. The</span>
<span class="sd">        type of the output is the same as the type of the difference</span>
<span class="sd">        between any two elements of `a`. This is the same as the type of</span>
<span class="sd">        `a` in most cases. A notable exception is `datetime64`, which</span>
<span class="sd">        results in a `timedelta64` output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    gradient, ediff1d, cumsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Type is preserved for boolean arrays, so the result will contain</span>
<span class="sd">    `False` when consecutive elements are the same and `True` when they</span>
<span class="sd">    differ.</span>

<span class="sd">    For unsigned integer arrays, the results will also be unsigned. This</span>
<span class="sd">    should not be surprising, as the result is consistent with</span>
<span class="sd">    calculating the difference directly:</span>

<span class="sd">    &gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(u8_arr)</span>
<span class="sd">    array([255], dtype=uint8)</span>
<span class="sd">    &gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...]</span>
<span class="sd">    255</span>

<span class="sd">    If this is not desirable, then the array should be cast to a larger</span>
<span class="sd">    integer type first:</span>

<span class="sd">    &gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(i16_arr)</span>
<span class="sd">    array([-1], dtype=int16)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([ 1,  2,  3, -7])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, n=2)</span>
<span class="sd">    array([  1,   1, -10])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([[2, 3, 4],</span>
<span class="sd">           [5, 1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, axis=0)</span>
<span class="sd">    array([[-1,  2,  0, -2]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(&#39;1066-10-13&#39;, &#39;1066-10-16&#39;, dtype=np.datetime64)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;order must be non-negative but got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diff requires input that is at least one dimensional&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

    <span class="n">combined</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">prepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">prepend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prepend</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">prepend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">prepend</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>

    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">not_equal</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">subtract</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">slice1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">slice2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_interp_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_interp_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional linear interpolation for monotonically increasing sample points.</span>

<span class="sd">    Returns the one-dimensional piecewise linear interpolant to a function</span>
<span class="sd">    with given discrete data points (`xp`, `fp`), evaluated at `x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The x-coordinates at which to evaluate the interpolated values.</span>

<span class="sd">    xp : 1-D sequence of floats</span>
<span class="sd">        The x-coordinates of the data points, must be increasing if argument</span>
<span class="sd">        `period` is not specified. Otherwise, `xp` is internally sorted after</span>
<span class="sd">        normalizing the periodic boundaries with ``xp = xp % period``.</span>

<span class="sd">    fp : 1-D sequence of float or complex</span>
<span class="sd">        The y-coordinates of the data points, same length as `xp`.</span>

<span class="sd">    left : optional float or complex corresponding to fp</span>
<span class="sd">        Value to return for `x &lt; xp[0]`, default is `fp[0]`.</span>

<span class="sd">    right : optional float or complex corresponding to fp</span>
<span class="sd">        Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.</span>

<span class="sd">    period : None or float, optional</span>
<span class="sd">        A period for the x-coordinates. This parameter allows the proper</span>
<span class="sd">        interpolation of angular x-coordinates. Parameters `left` and `right`</span>
<span class="sd">        are ignored if `period` is specified.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : float or complex (corresponding to fp) or ndarray</span>
<span class="sd">        The interpolated values, same shape as `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `xp` and `fp` have different length</span>
<span class="sd">        If `xp` or `fp` are not 1-D sequences</span>
<span class="sd">        If `period == 0`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.interpolate</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    The x-coordinate sequence is expected to be increasing, but this is not</span>
<span class="sd">    explicitly enforced.  However, if the sequence `xp` is non-increasing,</span>
<span class="sd">    interpolation results are meaningless.</span>

<span class="sd">    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.</span>

<span class="sd">    A simple check for `xp` being strictly increasing is::</span>

<span class="sd">        np.all(np.diff(xp) &gt; 0)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xp = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; fp = [3, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(2.5, xp, fp)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)</span>
<span class="sd">    array([3.  , 3.  , 2.5 , 0.56, 0.  ])</span>
<span class="sd">    &gt;&gt;&gt; UNDEF = -99.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)</span>
<span class="sd">    -99.0</span>

<span class="sd">    Plot an interpolant to the sine function:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; yinterp = np.interp(xvals, x, y)</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xvals, yinterp, &#39;-x&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Interpolation with periodic x-coordinates:</span>

<span class="sd">    &gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]</span>
<span class="sd">    &gt;&gt;&gt; xp = [190, -190, 350, -350]</span>
<span class="sd">    &gt;&gt;&gt; fp = [5, 10, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(x, xp, fp, period=360)</span>
<span class="sd">    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])</span>

<span class="sd">    Complex interpolation:</span>

<span class="sd">    &gt;&gt;&gt; x = [1.5, 4.0]</span>
<span class="sd">    &gt;&gt;&gt; xp = [2,3,5]</span>
<span class="sd">    &gt;&gt;&gt; fp = [1.0j, 0, 2+3j]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(x, xp, fp)</span>
<span class="sd">    array([0.+1.j , 1.+1.5j])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">compiled_interp_complex</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">compiled_interp</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;period must be a non-zero value&quot;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">fp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data points must be 1-D sequences&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fp and xp are not of the same length&quot;</span><span class="p">)</span>
        <span class="c1"># normalizing periodic boundaries</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">asort_xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">period</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">period</span><span class="p">))</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_angle_dispatcher</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">z</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_angle_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the angle of the complex argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        A complex number or sequence of complex numbers.</span>
<span class="sd">    deg : bool, optional</span>
<span class="sd">        Return angle in degrees if True, radians if False (default).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : ndarray or scalar</span>
<span class="sd">        The counterclockwise angle from the positive real axis on the complex</span>
<span class="sd">        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.</span>

<span class="sd">        .. versionchanged:: 1.16.0</span>
<span class="sd">            This function works on subclasses of ndarray like `ma.array`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arctan2</span>
<span class="sd">    absolute</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``</span>
<span class="sd">    returns the value 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians</span>
<span class="sd">    array([ 0.        ,  1.57079633,  0.78539816]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees</span>
<span class="sd">    45.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">arctan2</span><span class="p">(</span><span class="n">zimag</span><span class="p">,</span> <span class="n">zreal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">*=</span> <span class="mi">180</span><span class="o">/</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_unwrap_dispatcher</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_unwrap_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap by taking the complement of large deltas with respect to the period.</span>

<span class="sd">    This unwraps a signal `p` by changing elements which have an absolute</span>
<span class="sd">    difference from their predecessor of more than ``max(discont, period/2)``</span>
<span class="sd">    to their `period`-complementary values.</span>

<span class="sd">    For the default case where `period` is :math:`2\pi` and `discont` is</span>
<span class="sd">    :math:`\pi`, this unwraps a radian phase `p` such that adjacent differences</span>
<span class="sd">    are never greater than :math:`\pi` by adding :math:`2k\pi` for some</span>
<span class="sd">    integer :math:`k`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    discont : float, optional</span>
<span class="sd">        Maximum discontinuity between values, default is ``period/2``.</span>
<span class="sd">        Values below ``period/2`` are treated as if they were ``period/2``.</span>
<span class="sd">        To have an effect different from the default, `discont` should be</span>
<span class="sd">        larger than ``period/2``.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which unwrap will operate, default is the last axis.</span>
<span class="sd">    period : float, optional</span>
<span class="sd">        Size of the range over which the input wraps. By default, it is</span>
<span class="sd">        ``2 pi``.</span>

<span class="sd">        .. versionadded:: 1.21.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rad2deg, deg2rad</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the discontinuity in `p` is smaller than ``period/2``,</span>
<span class="sd">    but larger than `discont`, no unwrapping is done because taking</span>
<span class="sd">    the complement would only make the discontinuity larger.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)</span>
<span class="sd">    &gt;&gt;&gt; phase[3:] += np.pi</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap(phase)</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([0, 1, 2, -1, 0], period=4)</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)</span>
<span class="sd">    array([2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap(phase_deg, period=360)</span>
<span class="sd">    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,</span>
<span class="sd">            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,</span>
<span class="sd">            540.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">discont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">discont</span> <span class="o">=</span> <span class="n">period</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>     <span class="c1"># full slices</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_nx</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">interval_high</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">boundary_ambiguous</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interval_high</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">boundary_ambiguous</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">interval_low</span> <span class="o">=</span> <span class="o">-</span><span class="n">interval_high</span>
    <span class="n">ddmod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">-</span> <span class="n">interval_low</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="n">interval_low</span>
    <span class="k">if</span> <span class="n">boundary_ambiguous</span><span class="p">:</span>
        <span class="c1"># for `mask = (abs(dd) == period/2)`, the above line made</span>
        <span class="c1"># `ddmod[mask] == -period/2`. correct these such that</span>
        <span class="c1"># `ddmod[mask] == sign(dd[mask])*period/2`.</span>
        <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ddmod</span><span class="p">,</span> <span class="n">interval_high</span><span class="p">,</span>
                   <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">ddmod</span> <span class="o">==</span> <span class="n">interval_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span>
    <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">up</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ph_correct</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">up</span>


<span class="k">def</span> <span class="nf">_sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_sort_complex</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort a complex array using the real part first, then the imaginary part.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : complex ndarray</span>
<span class="sd">        Always returns a sorted complex array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])</span>
<span class="sd">    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])</span>

<span class="sd">    &gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])</span>
<span class="sd">    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;bhBH&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">filt</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_trim_zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim the leading and/or trailing zeros from a 1-D array or sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filt : 1-D array or sequence</span>
<span class="sd">        Input array.</span>
<span class="sd">    trim : str, optional</span>
<span class="sd">        A string with &#39;f&#39; representing trim from front and &#39;b&#39; to trim from</span>
<span class="sd">        back. Default is &#39;fb&#39;, trim zeros from both front and back of the</span>
<span class="sd">        array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trimmed : 1-D array or sequence</span>
<span class="sd">        The result of trimming the input. The input data type is preserved.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a)</span>
<span class="sd">    array([1, 2, 3, 0, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a, &#39;b&#39;)</span>
<span class="sd">    array([0, 0, 0, ..., 0, 2, 1])</span>

<span class="sd">    The input data type is preserved, list/tuple in means list/tuple out.</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;F&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;B&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_extract_dispatcher</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_extract_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the elements of an array that satisfy some condition.</span>

<span class="sd">    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If</span>
<span class="sd">    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.</span>

<span class="sd">    Note that `place` does the exact opposite of `extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like</span>
<span class="sd">        An array whose nonzero or True entries indicate the elements of `arr`</span>
<span class="sd">        to extract.</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array of the same size as `condition`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    extract : ndarray</span>
<span class="sd">        Rank 1 array of values from `arr` where `condition` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    take, put, copyto, compress, place</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11]])</span>
<span class="sd">    &gt;&gt;&gt; condition = np.mod(arr, 3)==0</span>
<span class="sd">    &gt;&gt;&gt; condition</span>
<span class="sd">    array([[ True, False, False,  True],</span>
<span class="sd">           [False, False,  True, False],</span>
<span class="sd">           [False,  True, False, False]])</span>
<span class="sd">    &gt;&gt;&gt; np.extract(condition, arr)</span>
<span class="sd">    array([0, 3, 6, 9])</span>


<span class="sd">    If `condition` is boolean:</span>

<span class="sd">    &gt;&gt;&gt; arr[condition]</span>
<span class="sd">    array([0, 3, 6, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_nx</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_place_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_place_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change elements of an array based on conditional and input values.</span>

<span class="sd">    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that</span>
<span class="sd">    `place` uses the first N elements of `vals`, where N is the number of</span>
<span class="sd">    True values in `mask`, while `copyto` uses the elements where `mask`</span>
<span class="sd">    is True.</span>

<span class="sd">    Note that `extract` does the exact opposite of `place`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Array to put data into.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Boolean mask array. Must have the same size as `a`.</span>
<span class="sd">    vals : 1-D sequence</span>
<span class="sd">        Values to put into `a`. Only the first N elements are used, where</span>
<span class="sd">        N is the number of True values in `mask`. If `vals` is smaller</span>
<span class="sd">        than N, it will be repeated, and if elements of `a` are to be masked,</span>
<span class="sd">        this sequence must be non-empty.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    copyto, put, take, extract</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2],</span>
<span class="sd">           [44, 55, 44]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument 1 must be numpy.ndarray, &quot;</span>
                        <span class="s2">&quot;not </span><span class="si">{name}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>


<div class="viewcode-block" id="disp"><a class="viewcode-back" href="../../../apis/auto/generated/brainpy.math.disp.html#brainpy.math.disp">[docs]</a><span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linefeed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display a message on a device.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesg : str</span>
<span class="sd">        Message to display.</span>
<span class="sd">    device : object</span>
<span class="sd">        Device to write message. If None, defaults to ``sys.stdout`` which is</span>
<span class="sd">        very similar to ``print``. `device` needs to have ``write()`` and</span>
<span class="sd">        ``flush()`` methods.</span>
<span class="sd">    linefeed : bool, optional</span>
<span class="sd">        Option whether to print a line feed or not. Defaults to True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If `device` does not have a ``write()`` or ``flush()`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Besides ``sys.stdout``, a file-like object can also be used as it has</span>
<span class="sd">    both required methods:</span>

<span class="sd">    &gt;&gt;&gt; from io import StringIO</span>
<span class="sd">    &gt;&gt;&gt; buf = StringIO()</span>
<span class="sd">    &gt;&gt;&gt; np.disp(u&#39;&quot;Display&quot; in a file&#39;, device=buf)</span>
<span class="sd">    &gt;&gt;&gt; buf.getvalue()</span>
<span class="sd">    &#39;&quot;Display&quot; in a file\\n&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="k">if</span> <span class="n">linefeed</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="n">device</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">return</span></div>


<span class="c1"># See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</span>
<span class="n">_DIMENSION_NAME</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\w+&#39;</span>
<span class="n">_CORE_DIMENSION_LIST</span> <span class="o">=</span> <span class="s1">&#39;(?:</span><span class="si">{0:}</span><span class="s1">(?:,</span><span class="si">{0:}</span><span class="s1">)*)?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_DIMENSION_NAME</span><span class="p">)</span>
<span class="n">_ARGUMENT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\(</span><span class="si">{}</span><span class="s1">\)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_CORE_DIMENSION_LIST</span><span class="p">)</span>
<span class="n">_ARGUMENT_LIST</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:}</span><span class="s1">(?:,</span><span class="si">{0:}</span><span class="s1">)*&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ARGUMENT</span><span class="p">)</span>
<span class="n">_SIGNATURE</span> <span class="o">=</span> <span class="s1">&#39;^</span><span class="si">{0:}</span><span class="s1">-&gt;</span><span class="si">{0:}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ARGUMENT_LIST</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_gufunc_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse string signatures for a generalized universal function.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    signature : string</span>
<span class="sd">        Generalized universal function signature, e.g., ``(m,n),(n,p)-&gt;(m,p)``</span>
<span class="sd">        for ``np.matmul``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple of input and output core dimensions parsed from the signature, each</span>
<span class="sd">    of the form List[Tuple[str, ...]].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">_SIGNATURE</span><span class="p">,</span> <span class="n">signature</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;not a valid gufunc signature: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">_DIMENSION_NAME</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">_ARGUMENT</span><span class="p">,</span> <span class="n">arg_list</span><span class="p">)]</span>
                 <span class="k">for</span> <span class="n">arg_list</span> <span class="ow">in</span> <span class="n">signature</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Incrementally check and update core dimension sizes for a single argument.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    dim_sizes : Dict[str, int]</span>
<span class="sd">        Sizes of existing core dimensions. Will be updated in-place.</span>
<span class="sd">    arg : ndarray</span>
<span class="sd">        Argument to examine.</span>
<span class="sd">    core_dims : Tuple[str, ...]</span>
<span class="sd">        Core dimensions for this argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core_dims</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">num_core_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">core_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">num_core_dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-dimensional argument does not have enough &#39;</span>
            <span class="s1">&#39;dimensions for all core dimensions </span><span class="si">%r</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">))</span>

    <span class="n">core_shape</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">num_core_dims</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">core_dims</span><span class="p">,</span> <span class="n">core_shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dim_sizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;inconsistent size for core dimension </span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1"> vs </span><span class="si">%r</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>


<span class="k">def</span> <span class="nf">_parse_input_dimensions</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse broadcast and core dimensions for vectorize with a signature.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    args : Tuple[ndarray, ...]</span>
<span class="sd">        Tuple of input arguments to examine.</span>
<span class="sd">    input_core_dims : List[Tuple[str, ...]]</span>
<span class="sd">        List of core dimensions corresponding to each input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    broadcast_shape : Tuple[int, ...]</span>
<span class="sd">        Common shape to broadcast all non-core dimensions to.</span>
<span class="sd">    dim_sizes : Dict[str, int]</span>
<span class="sd">        Common sizes for named core dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">broadcast_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">):</span>
        <span class="n">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">core_dims</span><span class="p">)</span>
        <span class="n">dummy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">broadcast_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dummy_array</span><span class="p">)</span>
    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">_broadcast_shape</span><span class="p">(</span><span class="o">*</span><span class="n">broadcast_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span>


<span class="k">def</span> <span class="nf">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for calculating broadcast shapes with core dimensions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">broadcast_shape</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">core_dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="n">list_of_core_dims</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span>
                   <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for creating output arrays in vectorize.&quot;&quot;&quot;</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="n">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span>
                       <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arrays</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">vectorize</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,</span>
<span class="sd">              signature=None)</span>

<span class="sd">    Generalized function class.</span>

<span class="sd">    Define a vectorized function which takes a nested sequence of objects or</span>
<span class="sd">    numpy arrays as inputs and returns a single numpy array or a tuple of numpy</span>
<span class="sd">    arrays. The vectorized function evaluates `pyfunc` over successive tuples</span>
<span class="sd">    of the input arrays like the python map function, except it uses the</span>
<span class="sd">    broadcasting rules of numpy.</span>

<span class="sd">    The data type of the output of `vectorized` is determined by calling</span>
<span class="sd">    the function with the first element of the input.  This can be avoided</span>
<span class="sd">    by specifying the `otypes` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pyfunc : callable</span>
<span class="sd">        A python function or method.</span>
<span class="sd">    otypes : str or list of dtypes, optional</span>
<span class="sd">        The output data type. It must be specified as either a string of</span>
<span class="sd">        typecode characters or a list of data type specifiers. There should</span>
<span class="sd">        be one data type specifier for each output.</span>
<span class="sd">    doc : str, optional</span>
<span class="sd">        The docstring for the function. If None, the docstring will be the</span>
<span class="sd">        ``pyfunc.__doc__``.</span>
<span class="sd">    excluded : set, optional</span>
<span class="sd">        Set of strings or integers representing the positional or keyword</span>
<span class="sd">        arguments for which the function will not be vectorized.  These will be</span>
<span class="sd">        passed directly to `pyfunc` unmodified.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    cache : bool, optional</span>
<span class="sd">        If `True`, then cache the first function call that determines the number</span>
<span class="sd">        of outputs if `otypes` is not provided.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    signature : string, optional</span>
<span class="sd">        Generalized universal function signature, e.g., ``(m,n),(n)-&gt;(m)`` for</span>
<span class="sd">        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will</span>
<span class="sd">        be called with (and expected to return) arrays with shapes given by the</span>
<span class="sd">        size of corresponding core dimensions. By default, ``pyfunc`` is</span>
<span class="sd">        assumed to take scalars as input and output.</span>

<span class="sd">        .. versionadded:: 1.12.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vectorized : callable</span>
<span class="sd">        Vectorized function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    frompyfunc : Takes an arbitrary Python function and returns a ufunc</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `vectorize` function is provided primarily for convenience, not for</span>
<span class="sd">    performance. The implementation is essentially a for loop.</span>

<span class="sd">    If `otypes` is not specified, then a call to the function with the</span>
<span class="sd">    first argument will be used to determine the number of outputs.  The</span>
<span class="sd">    results of this call will be cached if `cache` is `True` to prevent</span>
<span class="sd">    calling the function twice.  However, to implement the cache, the</span>
<span class="sd">    original function must be wrapped which will slow down subsequent</span>
<span class="sd">    calls, so only do this if your function is expensive.</span>

<span class="sd">    The new keyword argument interface and `excluded` argument support</span>
<span class="sd">    further degrades performance.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] :doc:`/reference/c-api/generalized-ufuncs`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def myfunc(a, b):</span>
<span class="sd">    ...     &quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span>
<span class="sd">    ...     if a &gt; b:</span>
<span class="sd">    ...         return a - b</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return a + b</span>

<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc)</span>
<span class="sd">    &gt;&gt;&gt; vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    array([3, 4, 1, 2])</span>

<span class="sd">    The docstring is taken from the input function to `vectorize` unless it</span>
<span class="sd">    is specified:</span>

<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Return a-b if a&gt;b, otherwise return a+b&#39;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, doc=&#39;Vectorized `myfunc`&#39;)</span>
<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Vectorized `myfunc`&#39;</span>

<span class="sd">    The output type is determined by evaluating the first element of the input,</span>
<span class="sd">    unless it is specified:</span>

<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, otypes=[float])</span>
<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;class &#39;numpy.float64&#39;&gt;</span>

<span class="sd">    The `excluded` argument can be used to prevent vectorizing over certain</span>
<span class="sd">    arguments.  This can be useful for array-like arguments of a fixed length</span>
<span class="sd">    such as the coefficients for a polynomial as in `polyval`:</span>

<span class="sd">    &gt;&gt;&gt; def mypolyval(p, x):</span>
<span class="sd">    ...     _p = list(p)</span>
<span class="sd">    ...     res = _p.pop(0)</span>
<span class="sd">    ...     while _p:</span>
<span class="sd">    ...         res = res*x + _p.pop(0)</span>
<span class="sd">    ...     return res</span>
<span class="sd">    &gt;&gt;&gt; vpolyval = np.vectorize(mypolyval, excluded=[&#39;p&#39;])</span>
<span class="sd">    &gt;&gt;&gt; vpolyval(p=[1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    Positional arguments may also be excluded by specifying their position:</span>

<span class="sd">    &gt;&gt;&gt; vpolyval.excluded.add(0)</span>
<span class="sd">    &gt;&gt;&gt; vpolyval([1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    The `signature` argument allows for vectorizing functions that act on</span>
<span class="sd">    non-scalar arrays of fixed length. For example, you can use it for a</span>
<span class="sd">    vectorized calculation of Pearson correlation coefficient and its p-value:</span>

<span class="sd">    &gt;&gt;&gt; import scipy.stats</span>
<span class="sd">    &gt;&gt;&gt; pearsonr = np.vectorize(scipy.stats.pearsonr,</span>
<span class="sd">    ...                 signature=&#39;(n),(n)-&gt;(),()&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])</span>
<span class="sd">    (array([ 1., -1.]), array([ 0.,  0.]))</span>

<span class="sd">    Or for a vectorized convolution:</span>

<span class="sd">    &gt;&gt;&gt; convolve = np.vectorize(np.convolve, signature=&#39;(n),(m)-&gt;(k)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; convolve(np.eye(4), [1, 2, 1])</span>
<span class="sd">    array([[1., 2., 1., 0., 0., 0.],</span>
<span class="sd">           [0., 1., 2., 1., 0., 0.],</span>
<span class="sd">           [0., 0., 1., 2., 1., 0.],</span>
<span class="sd">           [0., 0., 0., 1., 2., 1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyfunc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="o">=</span> <span class="n">pyfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="n">signature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># Caching to improve default performance</span>

        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">otypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">otypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid otype specified: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">char</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">otypes</span><span class="p">):</span>
            <span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_nx</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">char</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">otypes</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">otypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid otype specification&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="o">=</span> <span class="n">otypes</span>

        <span class="c1"># Excluded variable support</span>
        <span class="k">if</span> <span class="n">excluded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excluded</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span> <span class="o">=</span> <span class="n">_parse_gufunc_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays with the results of `pyfunc` broadcast (vectorized) over</span>
<span class="sd">        `args` and `kwargs` not in `excluded`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">excluded</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span>
            <span class="n">vargs</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The wrapper accepts only positional arguments: we use `names` and</span>
            <span class="c1"># `inds` to mutate `the_args` and `kwargs` to pass to the original</span>
            <span class="c1"># function.</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">_n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">the_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_n</span><span class="p">,</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
                    <span class="n">the_args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vargs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">):]))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span><span class="p">(</span><span class="o">*</span><span class="n">the_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">vargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]</span>
            <span class="n">vargs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">kwargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">vargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ufunc_and_otypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return (ufunc, otypes).&quot;&quot;&quot;</span>
        <span class="c1"># frompyfunc will fail if args is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;args can not be empty&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span>

            <span class="c1"># self._ufunc is a dictionary whose keys are the number of</span>
            <span class="c1"># arguments (i.e. len(args)) and whose values are ufuncs created</span>
            <span class="c1"># by frompyfunc. len(args) can be different for different calls if</span>
            <span class="c1"># self.pyfunc has parameters with default values.  We only use the</span>
            <span class="c1"># cache when func is self.pyfunc, which occurs when the call uses</span>
            <span class="c1"># only positional arguments and no arguments are excluded.</span>

            <span class="n">nin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">otypes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="ow">or</span> <span class="n">nin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">nin</span><span class="p">,</span> <span class="n">nout</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># We&#39;ll get it from self._ufunc</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get number of outputs and output types by calling the function on</span>
            <span class="c1"># the first entries of args.  We also cache the result to prevent</span>
            <span class="c1"># the subsequent call when the ufunc is evaluated.</span>
            <span class="c1"># Assumes that ufunc first evaluates the 0th elements in the input</span>
            <span class="c1"># arrays (the input values are not checked to ensure this)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` on size 0 inputs &#39;</span>
                                 <span class="s1">&#39;unless `otypes` is set&#39;</span><span class="p">)</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="c1"># Performance note: profiling indicates that -- for simple</span>
            <span class="c1"># functions at least -- this wrapping can almost double the</span>
            <span class="c1"># execution time.</span>
            <span class="c1"># Hence we make it optional.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_cache</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

            <span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="n">_k</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
                              <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nout</span><span class="p">)])</span>

            <span class="c1"># Performance note: profiling indicates that creating the ufunc is</span>
            <span class="c1"># not a significant cost compared with wrapping so it seems not</span>
            <span class="c1"># worth trying to cache this.</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nout</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span>

    <span class="k">def</span> <span class="nf">_vectorize_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized call to `func` over positional `args`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_call_with_signature</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ufunc_and_otypes</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># Convert args to object arrays first</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">otypes</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_vectorize_call_with_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized call over positional arguments with a signature.&quot;&quot;&quot;</span>
        <span class="n">input_core_dims</span><span class="p">,</span> <span class="n">output_core_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_core_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;wrong number of positional arguments: &#39;</span>
                            <span class="s1">&#39;expected </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_core_dims</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="n">_parse_input_dimensions</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">)</span>
        <span class="n">input_shapes</span> <span class="o">=</span> <span class="n">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                         <span class="n">input_core_dims</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_shapes</span><span class="p">)]</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span>
        <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_core_dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">broadcast_shape</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>

            <span class="n">n_results</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">nout</span> <span class="o">!=</span> <span class="n">n_results</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;wrong number of outputs from pyfunc: expected </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="n">n_results</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">,)</span>

            <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">output_core_dims</span><span class="p">):</span>
                    <span class="n">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">)</span>

                <span class="n">outputs</span> <span class="o">=</span> <span class="n">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                         <span class="n">output_core_dims</span><span class="p">,</span> <span class="n">otypes</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">output</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># did not call the function even once</span>
            <span class="k">if</span> <span class="n">otypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` on size 0 inputs &#39;</span>
                                 <span class="s1">&#39;unless `otypes` is set&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim_sizes</span>
                            <span class="k">for</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">output_core_dims</span>
                            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` with a signature &#39;</span>
                                 <span class="s1">&#39;including new output dimensions on size 0 &#39;</span>
                                 <span class="s1">&#39;inputs&#39;</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                     <span class="n">output_core_dims</span><span class="p">,</span> <span class="n">otypes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">outputs</span>


<span class="k">def</span> <span class="nf">_cov_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fweights</span><span class="p">,</span> <span class="n">aweights</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_cov_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate a covariance matrix, given data and weights.</span>

<span class="sd">    Covariance indicates the level to which two variables vary together.</span>
<span class="sd">    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,</span>
<span class="sd">    then the covariance matrix element :math:`C_{ij}` is the covariance of</span>
<span class="sd">    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance</span>
<span class="sd">    of :math:`x_i`.</span>

<span class="sd">    See the notes for an outline of the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `m` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same form</span>
<span class="sd">        as that of `m`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        Default normalization (False) is by ``(N - 1)``, where ``N`` is the</span>
<span class="sd">        number of observations given (unbiased estimate). If `bias` is True,</span>
<span class="sd">        then normalization is by ``N``. These values can be overridden by using</span>
<span class="sd">        the keyword ``ddof`` in numpy versions &gt;= 1.5.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        If not ``None`` the default value implied by `bias` is overridden.</span>
<span class="sd">        Note that ``ddof=1`` will return the unbiased estimate, even if both</span>
<span class="sd">        `fweights` and `aweights` are specified, and ``ddof=0`` will return</span>
<span class="sd">        the simple average. See the notes for the details. The default value</span>
<span class="sd">        is ``None``.</span>

<span class="sd">        .. versionadded:: 1.5</span>
<span class="sd">    fweights : array_like, int, optional</span>
<span class="sd">        1-D array of integer frequency weights; the number of times each</span>
<span class="sd">        observation vector should be repeated.</span>

<span class="sd">        .. versionadded:: 1.10</span>
<span class="sd">    aweights : array_like, optional</span>
<span class="sd">        1-D array of observation vector weights. These relative weights are</span>
<span class="sd">        typically large for observations considered &quot;important&quot; and smaller for</span>
<span class="sd">        observations considered less &quot;important&quot;. If ``ddof=0`` the array of</span>
<span class="sd">        weights can be used to assign probabilities to observation vectors.</span>

<span class="sd">        .. versionadded:: 1.10</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the result. By default, the return data-type will have</span>
<span class="sd">        at least `numpy.float64` precision.</span>

<span class="sd">        .. versionadded:: 1.20</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The covariance matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    corrcoef : Normalized covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assume that the observations are in the columns of the observation</span>
<span class="sd">    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The</span>
<span class="sd">    steps to compute the weighted covariance are as follows::</span>

<span class="sd">        &gt;&gt;&gt; m = np.arange(10, dtype=np.float64)</span>
<span class="sd">        &gt;&gt;&gt; f = np.arange(10) * 2</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(10) ** 2.</span>
<span class="sd">        &gt;&gt;&gt; ddof = 1</span>
<span class="sd">        &gt;&gt;&gt; w = f * a</span>
<span class="sd">        &gt;&gt;&gt; v1 = np.sum(w)</span>
<span class="sd">        &gt;&gt;&gt; v2 = np.sum(w * a)</span>
<span class="sd">        &gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1</span>
<span class="sd">        &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)</span>

<span class="sd">    Note that when ``a == 1``, the normalization factor</span>
<span class="sd">    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``</span>
<span class="sd">    as it should.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider two variables, :math:`x_0` and :math:`x_1`, which</span>
<span class="sd">    correlate perfectly, but in opposite directions:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [2, 1, 0]])</span>

<span class="sd">    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance</span>
<span class="sd">    matrix shows this clearly:</span>

<span class="sd">    &gt;&gt;&gt; np.cov(x)</span>
<span class="sd">    array([[ 1., -1.],</span>
<span class="sd">           [-1.,  1.]])</span>

<span class="sd">    Note that element :math:`C_{0,1}`, which shows the correlation between</span>
<span class="sd">    :math:`x_0` and :math:`x_1`, is negative.</span>

<span class="sd">    Further, note how `x` and `y` are combined:</span>

<span class="sd">    &gt;&gt;&gt; x = [-2.1, -1,  4.3]</span>
<span class="sd">    &gt;&gt;&gt; y = [3,  1.1,  0.12]</span>
<span class="sd">    &gt;&gt;&gt; X = np.stack((x, y), axis=0)</span>
<span class="sd">    &gt;&gt;&gt; np.cov(X)</span>
<span class="sd">    array([[11.71      , -4.286     ], # may vary</span>
<span class="sd">           [-4.286     ,  2.144133]])</span>
<span class="sd">    &gt;&gt;&gt; np.cov(x, y)</span>
<span class="sd">    array([[11.71      , -4.286     ], # may vary</span>
<span class="sd">           [-4.286     ,  2.144133]])</span>
<span class="sd">    &gt;&gt;&gt; np.cov(x)</span>
<span class="sd">    array(11.71)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check inputs</span>
    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ddof</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ddof</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;ddof must be integer&quot;</span><span class="p">)</span>

    <span class="c1"># Handles complex arrays too</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m has more than 2 dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y has more than 2 dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Get the product of frequencies and weights</span>
    <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fweights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">fweights</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;fweights must be integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">fweights</span>
    <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">aweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;aweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">aweights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">*=</span> <span class="n">aweights</span>

    <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Determine the normalization</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span>
    <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">aweights</span><span class="p">)</span><span class="o">/</span><span class="n">w_sum</span>

    <span class="k">if</span> <span class="n">fact</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="p">,</span>
                      <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">X</span> <span class="o">-=</span> <span class="n">avg</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
    <span class="n">c</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fact</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_corrcoef_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_corrcoef_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
             <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Pearson product-moment correlation coefficients.</span>

<span class="sd">    Please refer to the documentation for `cov` for more detail.  The</span>
<span class="sd">    relationship between the correlation coefficient matrix, `R`, and the</span>
<span class="sd">    covariance matrix, `C`, is</span>

<span class="sd">    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }</span>

<span class="sd">    The values of `R` are between -1 and 1, inclusive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `x` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same</span>
<span class="sd">        shape as `x`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : _NoValue, optional</span>
<span class="sd">        Has no effect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    ddof : _NoValue, optional</span>
<span class="sd">        Has no effect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the result. By default, the return data-type will have</span>
<span class="sd">        at least `numpy.float64` precision.</span>

<span class="sd">        .. versionadded:: 1.20</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        The correlation coefficient matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cov : Covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Due to floating point rounding the resulting array may not be Hermitian,</span>
<span class="sd">    the diagonal elements may not be 1, and the elements may not satisfy the</span>
<span class="sd">    inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the</span>
<span class="sd">    interval [-1,  1] in an attempt to improve on that situation but is not</span>
<span class="sd">    much help in the complex case.</span>

<span class="sd">    This function accepts but discards arguments `bias` and `ddof`.  This is</span>
<span class="sd">    for backwards compatibility with previous versions of this function.  These</span>
<span class="sd">    arguments had no effect on the return values of the function and can be</span>
<span class="sd">    safely ignored in this and previous versions of numpy.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example we generate two random arrays, ``xarr`` and ``yarr``, and</span>
<span class="sd">    compute the row-wise and column-wise Pearson correlation coefficients,</span>
<span class="sd">    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise</span>
<span class="sd">    Pearson correlation coefficients between the variables of ``xarr``.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng(seed=42)</span>
<span class="sd">    &gt;&gt;&gt; xarr = rng.random((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; xarr</span>
<span class="sd">    array([[0.77395605, 0.43887844, 0.85859792],</span>
<span class="sd">           [0.69736803, 0.09417735, 0.97562235],</span>
<span class="sd">           [0.7611397 , 0.78606431, 0.12811363]])</span>
<span class="sd">    &gt;&gt;&gt; R1 = np.corrcoef(xarr)</span>
<span class="sd">    &gt;&gt;&gt; R1</span>
<span class="sd">    array([[ 1.        ,  0.99256089, -0.68080986],</span>
<span class="sd">           [ 0.99256089,  1.        , -0.76492172],</span>
<span class="sd">           [-0.68080986, -0.76492172,  1.        ]])</span>

<span class="sd">    If we add another set of variables and observations ``yarr``, we can</span>
<span class="sd">    compute the row-wise Pearson correlation coefficients between the</span>
<span class="sd">    variables in ``xarr`` and ``yarr``.</span>

<span class="sd">    &gt;&gt;&gt; yarr = rng.random((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; yarr</span>
<span class="sd">    array([[0.45038594, 0.37079802, 0.92676499],</span>
<span class="sd">           [0.64386512, 0.82276161, 0.4434142 ],</span>
<span class="sd">           [0.22723872, 0.55458479, 0.06381726]])</span>
<span class="sd">    &gt;&gt;&gt; R2 = np.corrcoef(xarr, yarr)</span>
<span class="sd">    &gt;&gt;&gt; R2</span>
<span class="sd">    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,</span>
<span class="sd">            -0.99004057],</span>
<span class="sd">           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,</span>
<span class="sd">            -0.99981569],</span>
<span class="sd">           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,</span>
<span class="sd">             0.77714685],</span>
<span class="sd">           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,</span>
<span class="sd">            -0.83571711],</span>
<span class="sd">           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,</span>
<span class="sd">             0.97517215],</span>
<span class="sd">           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,</span>
<span class="sd">             1.        ]])</span>

<span class="sd">    Finally if we use the option ``rowvar=False``, the columns are now</span>
<span class="sd">    being treated as the variables and we will find the column-wise Pearson</span>
<span class="sd">    correlation coefficients between variables in ``xarr`` and ``yarr``.</span>

<span class="sd">    &gt;&gt;&gt; R3 = np.corrcoef(xarr, yarr, rowvar=False)</span>
<span class="sd">    &gt;&gt;&gt; R3</span>
<span class="sd">    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,</span>
<span class="sd">             0.22423734],</span>
<span class="sd">           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,</span>
<span class="sd">            -0.44069024],</span>
<span class="sd">           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,</span>
<span class="sd">             0.75137473],</span>
<span class="sd">           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,</span>
<span class="sd">             0.47536961],</span>
<span class="sd">           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,</span>
<span class="sd">            -0.46666491],</span>
<span class="sd">           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,</span>
<span class="sd">             1.        ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">or</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># 2015-03-15, 1.10</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;bias and ddof have no effect and are deprecated&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># scalar covariance</span>
        <span class="c1"># nan if incorrect value (nan, inf, 0), 1 otherwise</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">stddev</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">/=</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">/=</span> <span class="n">stddev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Clip real and imaginary parts to [-1, 1].  This does not guarantee</span>
    <span class="c1"># abs(a[i,j]) &lt;= 1 for complex arrays, but is the best we can do without</span>
    <span class="c1"># excessive work.</span>
    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">blackman</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Blackman window.</span>

<span class="sd">    The Blackman window is a taper formed by using the first three</span>
<span class="sd">    terms of a summation of cosines. It was designed to have close to the</span>
<span class="sd">    minimal leakage possible.  It is close to optimal, only slightly worse</span>
<span class="sd">    than a Kaiser window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an empty</span>
<span class="sd">        array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value one</span>
<span class="sd">        appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Blackman window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)</span>

<span class="sd">    Most references to the Blackman window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function. It is known as a</span>
<span class="sd">    &quot;near optimal&quot; tapering function, almost as good (by some measures)</span>
<span class="sd">    as the kaiser window.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,</span>
<span class="sd">    Dover Publications, New York.</span>

<span class="sd">    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.</span>
<span class="sd">    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.blackman(12)</span>
<span class="sd">    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary</span>
<span class="sd">            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span>
<span class="sd">            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span>
<span class="sd">            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span>

<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.blackman(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Blackman window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Blackman window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Blackman window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Blackman window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.42</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bartlett</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Bartlett window.</span>

<span class="sd">    The Bartlett window is very similar to a triangular window, except</span>
<span class="sd">    that the end points are at zero.  It is often used in signal</span>
<span class="sd">    processing for tapering a signal, without generating too much</span>
<span class="sd">    ripple in the frequency domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The triangular window, with the maximum value normalized to one</span>
<span class="sd">        (the value one appears only if the number of samples is odd), with</span>
<span class="sd">        the first and last samples equal to zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blackman, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Bartlett window is defined as</span>

<span class="sd">    .. math:: w(n) = \\frac{2}{M-1} \\left(</span>
<span class="sd">              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|</span>
<span class="sd">              \\right)</span>

<span class="sd">    Most references to the Bartlett window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  Note that convolution with this window produces linear</span>
<span class="sd">    interpolation.  It is also known as an apodization (which means &quot;removing</span>
<span class="sd">    the foot&quot;, i.e. smoothing discontinuities at the beginning and end of the</span>
<span class="sd">    sampled signal) or tapering function. The Fourier transform of the</span>
<span class="sd">    Bartlett window is the product of two sinc functions. Note the excellent</span>
<span class="sd">    discussion in Kanasewich [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,</span>
<span class="sd">           Biometrika 37, 1-16, 1950.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal</span>
<span class="sd">           Processing&quot;, Prentice-Hall, 1999, pp. 468-471.</span>
<span class="sd">    .. [4] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.bartlett(12)</span>
<span class="sd">    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary</span>
<span class="sd">            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span>
<span class="sd">            0.18181818,  0.        ])</span>

<span class="sd">    Plot the window and its frequency response (requires SciPy and matplotlib):</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.bartlett(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Bartlett window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Bartlett window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hanning window.</span>

<span class="sd">    The Hanning window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape(M,)</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if `M` is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hanning window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hanning was named for Julius von Hann, an Austrian meteorologist.</span>
<span class="sd">    It is also known as the Cosine Bell. Some authors prefer that it be</span>
<span class="sd">    called a Hann window, to help avoid confusion with the very similar</span>
<span class="sd">    Hamming window.</span>

<span class="sd">    Most references to the Hanning window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 106-108.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hanning(12)</span>
<span class="sd">    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,</span>
<span class="sd">           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,</span>
<span class="sd">           0.07937323, 0.        ])</span>

<span class="sd">    Plot the window and its frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hanning(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hann window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Hann window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of the Hann window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hamming window.</span>

<span class="sd">    The Hamming window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hamming window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey</span>
<span class="sd">    and is described in Blackman and Tukey. It was recommended for</span>
<span class="sd">    smoothing the truncated autocovariance function in the time domain.</span>
<span class="sd">    Most references to the Hamming window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hamming(12)</span>
<span class="sd">    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary</span>
<span class="sd">            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span>
<span class="sd">            0.15302337,  0.08      ])</span>

<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hamming(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hamming window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Hamming window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Hamming window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Hamming window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.54</span> <span class="o">+</span> <span class="mf">0.46</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="c1">## Code from cephes for i0</span>

<span class="n">_i0A</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">4.41534164647933937950E-18</span><span class="p">,</span>
    <span class="mf">3.33079451882223809783E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.43127984654795469359E-16</span><span class="p">,</span>
    <span class="mf">1.71539128555513303061E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.16853328779934516808E-14</span><span class="p">,</span>
    <span class="mf">7.67618549860493561688E-14</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.85644678311192946090E-13</span><span class="p">,</span>
    <span class="mf">2.95505266312963983461E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.72682629144155570723E-11</span><span class="p">,</span>
    <span class="mf">9.67580903537323691224E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.18979560163526290666E-10</span><span class="p">,</span>
    <span class="mf">2.65982372468238665035E-9</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.30002500998624804212E-8</span><span class="p">,</span>
    <span class="mf">6.04699502254191894932E-8</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.67079385394061173391E-7</span><span class="p">,</span>
    <span class="mf">1.11738753912010371815E-6</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.41673835845875056359E-6</span><span class="p">,</span>
    <span class="mf">1.64484480707288970893E-5</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.75419501008210370398E-5</span><span class="p">,</span>
    <span class="mf">1.88502885095841655729E-4</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.76375574538582365885E-4</span><span class="p">,</span>
    <span class="mf">1.63947561694133579842E-3</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.32430999505057594430E-3</span><span class="p">,</span>
    <span class="mf">1.05464603945949983183E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.37374148058994688156E-2</span><span class="p">,</span>
    <span class="mf">4.93052842396707084878E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.49010970480476444210E-2</span><span class="p">,</span>
    <span class="mf">1.71620901522208775349E-1</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.04682672343198398683E-1</span><span class="p">,</span>
    <span class="mf">6.76795274409476084995E-1</span>
    <span class="p">]</span>

<span class="n">_i0B</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">7.23318048787475395456E-18</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.83050448594418207126E-18</span><span class="p">,</span>
    <span class="mf">4.46562142029675999901E-17</span><span class="p">,</span>
    <span class="mf">3.46122286769746109310E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.82762398051658348494E-16</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.42548561967721913462E-16</span><span class="p">,</span>
    <span class="mf">1.77256013305652638360E-15</span><span class="p">,</span>
    <span class="mf">3.81168066935262242075E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.55484669882830764870E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.15056934728722208663E-14</span><span class="p">,</span>
    <span class="mf">1.54008621752140982691E-14</span><span class="p">,</span>
    <span class="mf">3.85277838274214270114E-13</span><span class="p">,</span>
    <span class="mf">7.18012445138366623367E-13</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.79417853150680611778E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.32158118404477131188E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.14991652796324136454E-11</span><span class="p">,</span>
    <span class="mf">1.18891471078464383424E-11</span><span class="p">,</span>
    <span class="mf">4.94060238822496958910E-10</span><span class="p">,</span>
    <span class="mf">3.39623202570838634515E-9</span><span class="p">,</span>
    <span class="mf">2.26666899049817806459E-8</span><span class="p">,</span>
    <span class="mf">2.04891858946906374183E-7</span><span class="p">,</span>
    <span class="mf">2.89137052083475648297E-6</span><span class="p">,</span>
    <span class="mf">6.88975834691682398426E-5</span><span class="p">,</span>
    <span class="mf">3.36911647825569408990E-3</span><span class="p">,</span>
    <span class="mf">8.04490411014108831608E-1</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b0</span>
        <span class="n">b0</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">b1</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b0</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">_i0A</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="mf">32.0</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">_i0B</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_i0_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modified Bessel function of the first kind, order 0.</span>

<span class="sd">    Usually denoted :math:`I_0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like of float</span>
<span class="sd">        Argument of the Bessel function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape = x.shape, dtype = float</span>
<span class="sd">        The modified Bessel function evaluated at each of the elements of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.special.i0, scipy.special.iv, scipy.special.ive</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The scipy implementation is recommended over this function: it is a</span>
<span class="sd">    proper ufunc written in C, and more than an order of magnitude faster.</span>

<span class="sd">    We use the algorithm published by Clenshaw [1]_ and referenced by</span>
<span class="sd">    Abramowitz and Stegun [2]_, for which the function domain is</span>
<span class="sd">    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev</span>
<span class="sd">    polynomial expansions are employed in each interval. Relative error on</span>
<span class="sd">    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a</span>
<span class="sd">    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] C. W. Clenshaw, &quot;Chebyshev series for mathematical functions&quot;, in</span>
<span class="sd">           *National Physical Laboratory Mathematical Tables*, vol. 5, London:</span>
<span class="sd">           Her Majesty&#39;s Stationery Office, 1962.</span>
<span class="sd">    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical</span>
<span class="sd">           Functions*, 10th printing, New York: Dover, 1964, pp. 379.</span>
<span class="sd">           https://personal.math.ubc.ca/~cbm/aands/page_379.htm</span>
<span class="sd">    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.i0(0.)</span>
<span class="sd">    array(1.0)</span>
<span class="sd">    &gt;&gt;&gt; np.i0([0, 1, 2, 3])</span>
<span class="sd">    array([1.        , 1.26606588, 2.2795853 , 4.88079259])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;i0 not supported for complex values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">8.0</span><span class="p">],</span> <span class="p">[</span><span class="n">_i0_1</span><span class="p">,</span> <span class="n">_i0_2</span><span class="p">])</span>

<span class="c1">## End of cephes code for i0</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">kaiser</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Kaiser window.</span>

<span class="sd">    The Kaiser window is a taper formed by using a Bessel function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Shape parameter for window.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, hanning</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Kaiser window is defined as</span>

<span class="sd">    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}</span>
<span class="sd">               \\right)/I_0(\\beta)</span>

<span class="sd">    with</span>

<span class="sd">    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},</span>

<span class="sd">    where :math:`I_0` is the modified zeroth-order Bessel function.</span>

<span class="sd">    The Kaiser was named for Jim Kaiser, who discovered a simple</span>
<span class="sd">    approximation to the DPSS window based on Bessel functions.  The Kaiser</span>
<span class="sd">    window is a very good approximation to the Digital Prolate Spheroidal</span>
<span class="sd">    Sequence, or Slepian window, which is the transform which maximizes the</span>
<span class="sd">    energy in the main lobe of the window relative to total energy.</span>

<span class="sd">    The Kaiser can approximate many other windows by varying the beta</span>
<span class="sd">    parameter.</span>

<span class="sd">    ====  =======================</span>
<span class="sd">    beta  Window shape</span>
<span class="sd">    ====  =======================</span>
<span class="sd">    0     Rectangular</span>
<span class="sd">    5     Similar to a Hamming</span>
<span class="sd">    6     Similar to a Hanning</span>
<span class="sd">    8.6   Similar to a Blackman</span>
<span class="sd">    ====  =======================</span>

<span class="sd">    A beta value of 14 is probably a good starting point. Note that as beta</span>
<span class="sd">    gets large, the window narrows, and so the number of samples needs to be</span>
<span class="sd">    large enough to sample the increasingly narrow spike, otherwise NaNs will</span>
<span class="sd">    get returned.</span>

<span class="sd">    Most references to the Kaiser window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by</span>
<span class="sd">           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.</span>
<span class="sd">           John Wiley and Sons, New York, (1966).</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 177-178.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.kaiser(12, 14)</span>
<span class="sd">     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary</span>
<span class="sd">            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,</span>
<span class="sd">            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,</span>
<span class="sd">            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])</span>


<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.kaiser(51, 14)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Kaiser window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Kaiser window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Kaiser window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Kaiser window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...) # may vary</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">i0</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))</span><span class="o">/</span><span class="n">i0</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_sinc_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_sinc_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the normalized sinc function.</span>

<span class="sd">    The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument</span>
<span class="sd">    :math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not</span>
<span class="sd">    only everywhere continuous but also infinitely differentiable.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Note the normalization factor of ``pi`` used in the definition.</span>
<span class="sd">        This is the most commonly used definition in signal processing.</span>
<span class="sd">        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function</span>
<span class="sd">        :math:`\sin(x)/x` that is more common in mathematics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Array (possibly multi-dimensional) of values for which to calculate</span>
<span class="sd">        ``sinc(x)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        ``sinc(x)``, which has the same shape as the input.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;.</span>

<span class="sd">    The sinc function is used in various signal processing applications,</span>
<span class="sd">    including in anti-aliasing, in the construction of a Lanczos resampling</span>
<span class="sd">    filter, and in interpolation.</span>

<span class="sd">    For bandlimited interpolation of discrete-time signals, the ideal</span>
<span class="sd">    interpolation kernel is proportional to the sinc function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web</span>
<span class="sd">           Resource. http://mathworld.wolfram.com/SincFunction.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Sinc function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Sinc_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-4, 4, 41)</span>
<span class="sd">    &gt;&gt;&gt; np.sinc(x)</span>
<span class="sd">     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary</span>
<span class="sd">            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="sd">            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="sd">            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="sd">            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="sd">            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="sd">            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="sd">            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="sd">            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="sd">           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="sd">           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="sd">            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="sd">            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="sd">            -4.92362781e-02,  -3.89804309e-17])</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, np.sinc(x))</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Sinc Function&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;X&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;X&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0e-20</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>


<span class="k">def</span> <span class="nf">_msort_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_msort_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">msort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of an array sorted along the first axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sorted_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal Function.</span>
<span class="sd">    Call `func` with `a` as first argument swapping the axes to use extended</span>
<span class="sd">    axis on functions that don&#39;t support it natively.</span>

<span class="sd">    Returns result and a.shape with axis dims set to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    func : callable</span>
<span class="sd">        Reduction function capable of receiving a single axis argument.</span>
<span class="sd">        It is called with `a` as first argument followed by `kwargs`.</span>
<span class="sd">    kwargs : keyword arguments</span>
<span class="sd">        additional keyword arguments to pass to `func`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : tuple</span>
<span class="sd">        Result of func(a, **kwargs) and a.shape with axis dims set to 1</span>
<span class="sd">        which can be used to reshape the result to the same shape a ufunc with</span>
<span class="sd">        keepdims=True would produce.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keepdim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="n">keepdim</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">nkeep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
            <span class="c1"># swap axis that should not be reduced to front</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># merge reduced axis</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">nkeep</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">keepdim</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keepdim</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keepdim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">keepdim</span>


<span class="k">def</span> <span class="nf">_median_dispatcher</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_median_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median along the specified axis.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : {int, sequence of int, None}, optional</span>
<span class="sd">        Axis or axes along which the medians are computed. The default</span>
<span class="sd">        is to compute the median along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">       If True, then allow use of memory of input array `a` for</span>
<span class="sd">       calculations. The input array will be modified by the call to</span>
<span class="sd">       `median`. This will save memory when you do not need to preserve</span>
<span class="sd">       the contents of the input array. Treat the input as undefined,</span>
<span class="sd">       but it will probably be fully or partially sorted. Default is</span>
<span class="sd">       False. If `overwrite_input` is ``True`` and `a` is not already an</span>
<span class="sd">       `ndarray`, an error will be raised.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        A new array holding the result. If the input contains integers</span>
<span class="sd">        or floats smaller than ``float64``, then the output data-type is</span>
<span class="sd">        ``np.float64``.  Otherwise, the data-type of the output is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, percentile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the median of ``V`` is the</span>
<span class="sd">    middle value of a sorted copy of ``V``, ``V_sorted`` - i</span>
<span class="sd">    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the</span>
<span class="sd">    two middle values of ``V_sorted`` when ``N`` is even.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; m = np.median(a, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0, out=m)</span>
<span class="sd">    array([6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_median</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># can&#39;t be reasonably be implemented in terms of percentile as we have to</span>
    <span class="c1"># call mean to not break astropy</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Set the partition indexes</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sz</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">szh</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[</span><span class="n">szh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">szh</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Check if the array contains any nan&#39;s</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="n">kth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">part</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="c1"># make 0-D arrays work</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">part</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># index with slice to allow mean (below) to work</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

    <span class="c1"># Use mean in both odd and even case to coerce data type,</span>
    <span class="c1"># using out array if needed.</span>
    <span class="n">rout</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="c1"># Check if the array contains any nan&#39;s</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># If nans are possible, warn and replace by nans like mean would.</span>
        <span class="n">rout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">_median_nancheck</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">rout</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rout</span>


<span class="k">def</span> <span class="nf">_percentile_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_percentile_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
               <span class="n">q</span><span class="p">,</span>
               <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
               <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">*</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the q-th percentile of the data along the specified axis.</span>

<span class="sd">    Returns the q-th percentile(s) of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : array_like of float</span>
<span class="sd">        Percentile or sequence of percentiles to compute, which must be between</span>
<span class="sd">        0 and 100 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the percentiles are computed. The</span>
<span class="sd">        default is to compute the percentile(s) along a flattened</span>
<span class="sd">        version of the array.</span>

<span class="sd">        .. versionchanged:: 1.9.0</span>
<span class="sd">            A tuple of axes is supported</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by intermediate</span>
<span class="sd">        calculations, to save memory. In this case, the contents of the input</span>
<span class="sd">        `a` after this function completes is undefined.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        This parameter specifies the method to use for estimating the</span>
<span class="sd">        percentile.  There are many different methods, some unique to NumPy.</span>
<span class="sd">        See the notes for explanation.  The options sorted by their R type</span>
<span class="sd">        as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">        1. &#39;inverted_cdf&#39;</span>
<span class="sd">        2. &#39;averaged_inverted_cdf&#39;</span>
<span class="sd">        3. &#39;closest_observation&#39;</span>
<span class="sd">        4. &#39;interpolated_inverted_cdf&#39;</span>
<span class="sd">        5. &#39;hazen&#39;</span>
<span class="sd">        6. &#39;weibull&#39;</span>
<span class="sd">        7. &#39;linear&#39;  (default)</span>
<span class="sd">        8. &#39;median_unbiased&#39;</span>
<span class="sd">        9. &#39;normal_unbiased&#39;</span>

<span class="sd">        The first three methods are discontiuous.  NumPy further defines the</span>
<span class="sd">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span>

<span class="sd">        * &#39;lower&#39;</span>
<span class="sd">        * &#39;higher&#39;,</span>
<span class="sd">        * &#39;midpoint&#39;</span>
<span class="sd">        * &#39;nearest&#39;</span>

<span class="sd">        .. versionchanged:: 1.22.0</span>
<span class="sd">            This argument was previously called &quot;interpolation&quot; and only</span>
<span class="sd">            offered the &quot;linear&quot; default and last four options.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Deprecated name for the method keyword argument.</span>

<span class="sd">        .. deprecated:: 1.22.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    percentile : scalar or ndarray</span>
<span class="sd">        If `q` is a single percentile and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple percentiles are given, first axis of</span>
<span class="sd">        the result corresponds to the percentiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float64``, the output</span>
<span class="sd">        data-type is ``float64``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    median : equivalent to ``percentile(..., 50)``</span>
<span class="sd">    nanpercentile</span>
<span class="sd">    quantile : equivalent to percentile, except q in the range [0, 1].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the q-th percentile of ``V`` is</span>
<span class="sd">    the value ``q/100`` of the way from the minimum to the maximum in a</span>
<span class="sd">    sorted copy of ``V``. The values and distances of the two nearest</span>
<span class="sd">    neighbors as well as the `method` parameter will determine the</span>
<span class="sd">    percentile if the normalized ranking does not match the location of</span>
<span class="sd">    ``q`` exactly. This function is the same as the median if ``q=50``, the</span>
<span class="sd">    same as the minimum if ``q=0`` and the same as the maximum if</span>
<span class="sd">    ``q=100``.</span>

<span class="sd">    This optional `method` parameter specifies the method to use when the</span>
<span class="sd">    desired quantile lies between two data points ``i &lt; j``.</span>
<span class="sd">    If ``g`` is the fractional part of the index surrounded by ``i`` and</span>
<span class="sd">    alpha and beta are correction constants modifying i and j.</span>

<span class="sd">    Below, &#39;q&#39; is the quantile value, &#39;n&#39; is the sample size and</span>
<span class="sd">    alpha and beta are constants.</span>
<span class="sd">    The following formula gives an interpolation &quot;i + g&quot; of where the quantile</span>
<span class="sd">    would be in the sorted sample.</span>
<span class="sd">    With &#39;i&#39; being the floor and &#39;g&#39; the fractional part of the result.</span>

<span class="sd">    .. math::</span>
<span class="sd">        i + g = (q - alpha) / ( n - alpha - beta + 1 )</span>

<span class="sd">    The different methods then work as follows</span>

<span class="sd">    inverted_cdf:</span>
<span class="sd">        method 1 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then take i</span>

<span class="sd">    averaged_inverted_cdf:</span>
<span class="sd">        method 2 of H&amp;F [1]_.</span>
<span class="sd">        This method give discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then average between bounds</span>

<span class="sd">    closest_observation:</span>
<span class="sd">        method 3 of H&amp;F [1]_.</span>
<span class="sd">        This method give discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 and index is odd ; then take j</span>
<span class="sd">        * if g = 0 and index is even ; then take i</span>

<span class="sd">    interpolated_inverted_cdf:</span>
<span class="sd">        method 4 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    hazen:</span>
<span class="sd">        method 5 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1/2</span>
<span class="sd">        * beta = 1/2</span>

<span class="sd">    weibull:</span>
<span class="sd">        method 6 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 0</span>

<span class="sd">    linear:</span>
<span class="sd">        method 7 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    median_unbiased:</span>
<span class="sd">        method 8 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is unknown (see reference).</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1/3</span>
<span class="sd">        * beta = 1/3</span>

<span class="sd">    normal_unbiased:</span>
<span class="sd">        method 9 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is known to be normal.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 3/8</span>
<span class="sd">        * beta = 3/8</span>

<span class="sd">    lower:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` as the interpolation point.</span>

<span class="sd">    higher:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``j`` as the interpolation point.</span>

<span class="sd">    nearest:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` or ``j``, whichever is nearest.</span>

<span class="sd">    midpoint:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Uses ``(i + j) / 2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)</span>
<span class="sd">    array([[7.],</span>
<span class="sd">           [2.]])</span>

<span class="sd">    &gt;&gt;&gt; m = np.percentile(a, 50, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>

<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a == b)</span>

<span class="sd">    The different methods can be visualized graphically:</span>

<span class="sd">    .. plot::</span>

<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        a = np.arange(4)</span>
<span class="sd">        p = np.linspace(0, 100, 6001)</span>
<span class="sd">        ax = plt.gca()</span>
<span class="sd">        lines = [</span>
<span class="sd">            (&#39;linear&#39;, &#39;-&#39;, &#39;C0&#39;),</span>
<span class="sd">            (&#39;inverted_cdf&#39;, &#39;:&#39;, &#39;C1&#39;),</span>
<span class="sd">            # Almost the same as `inverted_cdf`:</span>
<span class="sd">            (&#39;averaged_inverted_cdf&#39;, &#39;-.&#39;, &#39;C1&#39;),</span>
<span class="sd">            (&#39;closest_observation&#39;, &#39;:&#39;, &#39;C2&#39;),</span>
<span class="sd">            (&#39;interpolated_inverted_cdf&#39;, &#39;--&#39;, &#39;C1&#39;),</span>
<span class="sd">            (&#39;hazen&#39;, &#39;--&#39;, &#39;C3&#39;),</span>
<span class="sd">            (&#39;weibull&#39;, &#39;-.&#39;, &#39;C4&#39;),</span>
<span class="sd">            (&#39;median_unbiased&#39;, &#39;--&#39;, &#39;C5&#39;),</span>
<span class="sd">            (&#39;normal_unbiased&#39;, &#39;-.&#39;, &#39;C6&#39;),</span>
<span class="sd">            ]</span>
<span class="sd">        for method, style, color in lines:</span>
<span class="sd">            ax.plot(</span>
<span class="sd">                p, np.percentile(a, p, method=method),</span>
<span class="sd">                label=method, linestyle=style, color=color)</span>
<span class="sd">        ax.set(</span>
<span class="sd">            title=&#39;Percentiles for different methods and data: &#39; + str(a),</span>
<span class="sd">            xlabel=&#39;Percentile&#39;,</span>
<span class="sd">            ylabel=&#39;Estimated percentile value&#39;,</span>
<span class="sd">            yticks=a)</span>
<span class="sd">        ax.legend()</span>
<span class="sd">        plt.show()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">       &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">       The American Statistician, 50(4), pp. 361-365, 1996</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_check_interpolation_as_method</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="s2">&quot;percentile&quot;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># undo any decay that the ufunc performed (see gh-13105)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0, 100]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_quantile_unchecked</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_quantile_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
             <span class="n">q</span><span class="p">,</span>
             <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
             <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="o">*</span><span class="p">,</span>
             <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the q-th quantile of the data along the specified axis.</span>

<span class="sd">    .. versionadded:: 1.15.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : array_like of float</span>
<span class="sd">        Quantile or sequence of quantiles to compute, which must be between</span>
<span class="sd">        0 and 1 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the quantiles are computed. The default is</span>
<span class="sd">        to compute the quantile(s) along a flattened version of the array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape and buffer length as the expected output, but the</span>
<span class="sd">        type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by</span>
<span class="sd">        intermediate calculations, to save memory. In this case, the</span>
<span class="sd">        contents of the input `a` after this function completes is</span>
<span class="sd">        undefined.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        This parameter specifies the method to use for estimating the</span>
<span class="sd">        quantile.  There are many different methods, some unique to NumPy.</span>
<span class="sd">        See the notes for explanation.  The options sorted by their R type</span>
<span class="sd">        as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">        1. &#39;inverted_cdf&#39;</span>
<span class="sd">        2. &#39;averaged_inverted_cdf&#39;</span>
<span class="sd">        3. &#39;closest_observation&#39;</span>
<span class="sd">        4. &#39;interpolated_inverted_cdf&#39;</span>
<span class="sd">        5. &#39;hazen&#39;</span>
<span class="sd">        6. &#39;weibull&#39;</span>
<span class="sd">        7. &#39;linear&#39;  (default)</span>
<span class="sd">        8. &#39;median_unbiased&#39;</span>
<span class="sd">        9. &#39;normal_unbiased&#39;</span>

<span class="sd">        The first three methods are discontinuous.  NumPy further defines the</span>
<span class="sd">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span>

<span class="sd">        * &#39;lower&#39;</span>
<span class="sd">        * &#39;higher&#39;,</span>
<span class="sd">        * &#39;midpoint&#39;</span>
<span class="sd">        * &#39;nearest&#39;</span>

<span class="sd">        .. versionchanged:: 1.22.0</span>
<span class="sd">            This argument was previously called &quot;interpolation&quot; and only</span>
<span class="sd">            offered the &quot;linear&quot; default and last four options.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Deprecated name for the method keyword argument.</span>

<span class="sd">        .. deprecated:: 1.22.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantile : scalar or ndarray</span>
<span class="sd">        If `q` is a single quantile and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple quantiles are given, first axis of</span>
<span class="sd">        the result corresponds to the quantiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float64``, the output</span>
<span class="sd">        data-type is ``float64``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    percentile : equivalent to quantile, but with q in the range [0, 100].</span>
<span class="sd">    median : equivalent to ``quantile(..., 0.5)``</span>
<span class="sd">    nanquantile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the q-th quantile of ``V`` is the</span>
<span class="sd">    value ``q`` of the way from the minimum to the maximum in a sorted copy of</span>
<span class="sd">    ``V``. The values and distances of the two nearest neighbors as well as the</span>
<span class="sd">    `method` parameter will determine the quantile if the normalized</span>
<span class="sd">    ranking does not match the location of ``q`` exactly. This function is the</span>
<span class="sd">    same as the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and</span>
<span class="sd">    the same as the maximum if ``q=1.0``.</span>

<span class="sd">    The optional `method` parameter specifies the method to use when the</span>
<span class="sd">    desired quantile lies between two data points ``i &lt; j``.</span>
<span class="sd">    If ``g`` is the fractional part of the index surrounded by ``i`` and ``j``,</span>
<span class="sd">    and alpha and beta are correction constants modifying i and j:</span>

<span class="sd">    .. math::</span>
<span class="sd">        i + g = (q - alpha) / ( n - alpha - beta + 1 )</span>

<span class="sd">    The different methods then work as follows</span>

<span class="sd">    inverted_cdf:</span>
<span class="sd">        method 1 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then take i</span>

<span class="sd">    averaged_inverted_cdf:</span>
<span class="sd">        method 2 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then average between bounds</span>

<span class="sd">    closest_observation:</span>
<span class="sd">        method 3 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 and index is odd ; then take j</span>
<span class="sd">        * if g = 0 and index is even ; then take i</span>

<span class="sd">    interpolated_inverted_cdf:</span>
<span class="sd">        method 4 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    hazen:</span>
<span class="sd">        method 5 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1/2</span>
<span class="sd">        * beta = 1/2</span>

<span class="sd">    weibull:</span>
<span class="sd">        method 6 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 0</span>

<span class="sd">    linear:</span>
<span class="sd">        method 7 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    median_unbiased:</span>
<span class="sd">        method 8 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is unknown (see reference).</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1/3</span>
<span class="sd">        * beta = 1/3</span>

<span class="sd">    normal_unbiased:</span>
<span class="sd">        method 9 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is known to be normal.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 3/8</span>
<span class="sd">        * beta = 3/8</span>

<span class="sd">    lower:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` as the interpolation point.</span>

<span class="sd">    higher:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``j`` as the interpolation point.</span>

<span class="sd">    nearest:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` or ``j``, whichever is nearest.</span>

<span class="sd">    midpoint:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Uses ``(i + j) / 2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)</span>
<span class="sd">    array([[7.],</span>
<span class="sd">           [2.]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a == b)</span>

<span class="sd">    See also `numpy.percentile` for a visualization of most methods.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">       &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">       The American Statistician, 50(4), pp. 361-365, 1996</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_check_interpolation_as_method</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantiles must be in the range [0, 1]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_quantile_unchecked</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_unchecked</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
                        <span class="n">q</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assumes that q is in [0, 1], and is an ndarray&quot;&quot;&quot;</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
                    <span class="n">func</span><span class="o">=</span><span class="n">_quantile_ureduce_func</span><span class="p">,</span>
                    <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="c1"># avoid expensive reductions, relevant for arrays with &lt; O(1000) elements</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_check_interpolation_as_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="c1"># Deprecated NumPy 1.22, 2021-11-08</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;the `interpolation=` argument to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> was renamed to &quot;</span>
        <span class="s2">&quot;`method=`, which has additional options.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Users of the modes &#39;nearest&#39;, &#39;lower&#39;, &#39;higher&#39;, or &quot;</span>
        <span class="s2">&quot;&#39;midpoint&#39; are encouraged to review the method they used. &quot;</span>
        <span class="s2">&quot;(Deprecated NumPy 1.22)&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="c1"># sanity check, we assume this basically never happens</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;You shall not pass both `method` and `interpolation`!</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;(`interpolation` is Deprecated in favor of `method`)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolation</span>


<span class="k">def</span> <span class="nf">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the floating point indexes of an array for the linear</span>
<span class="sd">    interpolation of quantiles.</span>
<span class="sd">    n : array_like</span>
<span class="sd">        The sample sizes.</span>
<span class="sd">    quantiles : array_like</span>
<span class="sd">        The quantiles values.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        A constant used to correct the index computed.</span>
<span class="sd">    beta : float</span>
<span class="sd">        A constant used to correct the index computed.</span>

<span class="sd">    alpha and beta values depend on the chosen method</span>
<span class="sd">    (see quantile documentation)</span>

<span class="sd">    Reference:</span>
<span class="sd">    Hyndman&amp;Fan paper &quot;Sample Quantiles in Statistical Packages&quot;,</span>
<span class="sd">    DOI: 10.1080/00031305.1996.10473566</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">alpha</span> <span class="o">+</span> <span class="n">quantiles</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_gamma</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute gamma (a.k.a &#39;m&#39; or &#39;weight&#39;) for the linear interpolation</span>
<span class="sd">    of quantiles.</span>

<span class="sd">    virtual_indexes : array_like</span>
<span class="sd">        The indexes where the percentile is supposed to be found in the sorted</span>
<span class="sd">        sample.</span>
<span class="sd">    previous_indexes : array_like</span>
<span class="sd">        The floor values of virtual_indexes.</span>
<span class="sd">    interpolation : dict</span>
<span class="sd">        The interpolation method chosen, which may have a specific rule</span>
<span class="sd">        modifying gamma.</span>

<span class="sd">    gamma is usually the fractional part of virtual_indexes but can be modified</span>
<span class="sd">    by the interpolation method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">virtual_indexes</span> <span class="o">-</span> <span class="n">previous_indexes</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s2">&quot;fix_gamma&quot;</span><span class="p">](</span><span class="n">gamma</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the linear interpolation weighted by gamma on each point of</span>
<span class="sd">    two same shape array.</span>

<span class="sd">    a : array_like</span>
<span class="sd">        Left bound.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Right bound.</span>
<span class="sd">    t : array_like</span>
<span class="sd">        The interpolation weight.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Output array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_b_a</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="c1"># asanyarray is a stop-gap until gh-13105</span>
    <span class="n">lerp_interpolation</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">diff_b_a</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">))</span>
    <span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">diff_b_a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">lerp_interpolation</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lerp_interpolation</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lerp_interpolation</span> <span class="o">=</span> <span class="n">lerp_interpolation</span><span class="p">[()]</span>  <span class="c1"># unpack 0d arrays</span>
    <span class="k">return</span> <span class="n">lerp_interpolation</span>


<span class="k">def</span> <span class="nf">_get_gamma_mask</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">conditioned_value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">conditioned_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;unsafe&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_discret_interpolation_to_boundaries</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">gamma_condition_fun</span><span class="p">):</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">previous</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_get_gamma_mask</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                          <span class="n">default_value</span><span class="o">=</span><span class="nb">next</span><span class="p">,</span>
                          <span class="n">conditioned_value</span><span class="o">=</span><span class="n">previous</span><span class="p">,</span>
                          <span class="n">where</span><span class="o">=</span><span class="n">gamma_condition_fun</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                          <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="c1"># Some methods can lead to out-of-bound integers, clip them:</span>
    <span class="n">res</span><span class="p">[</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_closest_observation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
    <span class="n">gamma_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_discret_interpolation_to_boundaries</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                                                <span class="n">gamma_fun</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_inverted_cdf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
    <span class="n">gamma_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_discret_interpolation_to_boundaries</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                <span class="n">gamma_fun</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_ureduce_func</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># The code below works fine for nd, but it might not have useful</span>
        <span class="c1"># semantics. For now, keep the supported dimensions the same as it was</span>
        <span class="c1"># before.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q must be a scalar or 1d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                       <span class="n">quantiles</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
                       <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                       <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_get_indexes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">valid_values_count</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the valid indexes of arr neighbouring virtual_indexes.</span>
<span class="sd">    Note</span>
<span class="sd">    This is a companion function to linear interpolation of</span>
<span class="sd">    Quantiles</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (previous_indexes, next_indexes): Tuple</span>
<span class="sd">        A Tuple of virtual_indexes neighbouring indexes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">previous_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">))</span>
    <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">previous_indexes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">indexes_above_bounds</span> <span class="o">=</span> <span class="n">virtual_indexes</span> <span class="o">&gt;=</span> <span class="n">valid_values_count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># When indexes is above max index, take the max value of the array</span>
    <span class="k">if</span> <span class="n">indexes_above_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">previous_indexes</span><span class="p">[</span><span class="n">indexes_above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">next_indexes</span><span class="p">[</span><span class="n">indexes_above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># When indexes is below min index, take the min value of the array</span>
    <span class="n">indexes_below_bounds</span> <span class="o">=</span> <span class="n">virtual_indexes</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">indexes_below_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">previous_indexes</span><span class="p">[</span><span class="n">indexes_below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_indexes</span><span class="p">[</span><span class="n">indexes_below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="c1"># After the sort, slices having NaNs will have for last element a NaN</span>
        <span class="n">virtual_indexes_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_indexes_nans</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">previous_indexes</span><span class="p">[</span><span class="n">virtual_indexes_nans</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">next_indexes</span><span class="p">[</span><span class="n">virtual_indexes_nans</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">previous_indexes</span> <span class="o">=</span> <span class="n">previous_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">next_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">next_indexes</span>


<span class="k">def</span> <span class="nf">_quantile</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function that doesn&#39;t support extended axis or keepdims.</span>
<span class="sd">    These methods are extended to this function using _ureduce</span>
<span class="sd">    See nanpercentile for parameter usage</span>
<span class="sd">    It computes the quantiles of the array for the given axis.</span>
<span class="sd">    A linear interpolation is performed based on the `interpolation`.</span>

<span class="sd">    By default, the method is &quot;linear&quot; where alpha == beta == 1 which</span>
<span class="sd">    performs the 7th method of Hyndman&amp;Fan.</span>
<span class="sd">    With &quot;median_unbiased&quot; we get alpha == beta == 1/3</span>
<span class="sd">    thus the 8th method of Hyndman&amp;Fan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># --- Setup</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">values_count</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="c1"># The dimensions of `q` are prepended to the output shape, so we need the</span>
    <span class="c1"># axis being sampled from `arr` to be last.</span>
    <span class="n">DATA_AXIS</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">DATA_AXIS</span><span class="p">:</span>  <span class="c1"># But moveaxis is slow, so only call it if axis!=0.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">DATA_AXIS</span><span class="p">)</span>
    <span class="c1"># --- Computation of indexes</span>
    <span class="c1"># Index where to find the value in the sorted array.</span>
    <span class="c1"># Virtual because it is a floating point value, not an valid index.</span>
    <span class="c1"># The nearest neighbours are used for interpolation</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_QuantileMethods</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">!r}</span><span class="s2"> is not a valid method. Use one of: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_QuantileMethods</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
    <span class="n">virtual_indexes</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s2">&quot;get_virtual_index&quot;</span><span class="p">](</span><span class="n">values_count</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">)</span>
    <span class="n">virtual_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="c1"># No interpolation needed, take the points along axis</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="c1"># may contain nan, which would sort to the end</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">concatenate</span><span class="p">((</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cannot contain nan</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">_get_indexes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                                                      <span class="n">virtual_indexes</span><span class="p">,</span>
                                                      <span class="n">values_count</span><span class="p">)</span>
        <span class="c1"># --- Sorting</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">previous_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                      <span class="n">next_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                      <span class="p">))),</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">DATA_AXIS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span>
                <span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">DATA_AXIS</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># --- Get values from indexes</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">DATA_AXIS</span><span class="p">)</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">next_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">DATA_AXIS</span><span class="p">)</span>
        <span class="c1"># --- Linear interpolation</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">_get_gamma</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">virtual_indexes</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_lerp</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span>
                       <span class="nb">next</span><span class="p">,</span>
                       <span class="n">gamma</span><span class="p">,</span>
                       <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">slices_having_nans</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># can&#39;t write to a scalar</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">slices_having_nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_trapz_dispatcher</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_trapz_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate along the given axis using the composite trapezoidal rule.</span>

<span class="sd">    If `x` is provided, the integration happens in sequence along its</span>
<span class="sd">    elements - they are not sorted.</span>

<span class="sd">    Integrate `y` (`x`) along each 1d slice on the given axis, compute</span>
<span class="sd">    :math:`\int y(x) dx`.</span>
<span class="sd">    When `x` is specified, this integrates along the parametric curve,</span>
<span class="sd">    computing :math:`\int_t y(t) dt =</span>
<span class="sd">    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Input array to integrate.</span>
<span class="sd">    x : array_like, optional</span>
<span class="sd">        The sample points corresponding to the `y` values. If `x` is None,</span>
<span class="sd">        the sample points are assumed to be evenly spaced `dx` apart. The</span>
<span class="sd">        default is None.</span>
<span class="sd">    dx : scalar, optional</span>
<span class="sd">        The spacing between sample points when `x` is None. The default is 1.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to integrate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trapz : float or ndarray</span>
<span class="sd">        Definite integral of `y` = n-dimensional array as approximated along</span>
<span class="sd">        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,</span>
<span class="sd">        then the result is a float. If `n` is greater than 1, then the result</span>
<span class="sd">        is an `n`-1 dimensional array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sum, cumsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points</span>
<span class="sd">    will be taken from `y` array, by default x-axis distances between</span>
<span class="sd">    points will be 1.0, alternatively they can be provided with `x` array</span>
<span class="sd">    or with `dx` scalar.  Return value will be equal to combined area under</span>
<span class="sd">    the red lines.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule</span>

<span class="sd">    .. [2] Illustration image:</span>
<span class="sd">           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3])</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])</span>
<span class="sd">    8.0</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3], dx=2)</span>
<span class="sd">    8.0</span>

<span class="sd">    Using a decreasing `x` corresponds to integrating in reverse:</span>

<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3], x=[8,6,4])</span>
<span class="sd">    -8.0</span>

<span class="sd">    More generally `x` is used to integrate along a parametric curve.</span>
<span class="sd">    This finds the area of a circle, noting we repeat the sample which closes</span>
<span class="sd">    the curve:</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(np.cos(theta), x=np.sin(theta))</span>
<span class="sd">    3.141571941375841</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=0)</span>
<span class="sd">    array([1.5, 2.5, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=1)</span>
<span class="sd">    array([2.,  8.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># reshape to correct shape</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># Operations didn&#39;t work, cast to ndarray</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span><span class="o">+</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_meshgrid_dispatcher</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xi</span>


<span class="c1"># Based on scitools meshgrid</span>
<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_meshgrid_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return coordinate matrices from coordinate vectors.</span>

<span class="sd">    Make N-D coordinate arrays for vectorized evaluations of</span>
<span class="sd">    N-D scalar/vector fields over N-D grids, given</span>
<span class="sd">    one-dimensional coordinate arrays x1, x2,..., xn.</span>

<span class="sd">    .. versionchanged:: 1.9</span>
<span class="sd">       1-D and 0-D cases are allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2,..., xn : array_like</span>
<span class="sd">        1-D arrays representing the coordinates of a grid.</span>
<span class="sd">    indexing : {&#39;xy&#39;, &#39;ij&#39;}, optional</span>
<span class="sd">        Cartesian (&#39;xy&#39;, default) or matrix (&#39;ij&#39;) indexing of output.</span>
<span class="sd">        See Notes for more details.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    sparse : bool, optional</span>
<span class="sd">        If True the shape of the returned coordinate array for dimension *i*</span>
<span class="sd">        is reduced from ``(N1, ..., Ni, ... Nn)`` to</span>
<span class="sd">        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are</span>
<span class="sd">        intended to be use with :ref:`basics.broadcasting`.  When all</span>
<span class="sd">        coordinates are used in an expression, broadcasting still leads to a</span>
<span class="sd">        fully-dimensonal result array.</span>

<span class="sd">        Default is False.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If False, a view into the original arrays are returned in order to</span>
<span class="sd">        conserve memory.  Default is True.  Please note that</span>
<span class="sd">        ``sparse=False, copy=False`` will likely return non-contiguous</span>
<span class="sd">        arrays.  Furthermore, more than one element of a broadcast array</span>
<span class="sd">        may refer to a single memory location.  If you need to write to the</span>
<span class="sd">        arrays, make copies first.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X1, X2,..., XN : ndarray</span>
<span class="sd">        For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,</span>
<span class="sd">        returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing=&#39;ij&#39;</span>
<span class="sd">        or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing=&#39;xy&#39;</span>
<span class="sd">        with the elements of `xi` repeated to fill the matrix along</span>
<span class="sd">        the first dimension for `x1`, the second for `x2` and so on.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function supports both indexing conventions through the indexing</span>
<span class="sd">    keyword argument.  Giving the string &#39;ij&#39; returns a meshgrid with</span>
<span class="sd">    matrix indexing, while &#39;xy&#39; returns a meshgrid with Cartesian indexing.</span>
<span class="sd">    In the 2-D case with inputs of length M and N, the outputs are of shape</span>
<span class="sd">    (N, M) for &#39;xy&#39; indexing and (M, N) for &#39;ij&#39; indexing.  In the 3-D case</span>
<span class="sd">    with inputs of length M, N and P, outputs are of shape (N, M, P) for</span>
<span class="sd">    &#39;xy&#39; indexing and (M, N, P) for &#39;ij&#39; indexing.  The difference is</span>
<span class="sd">    illustrated by the following code snippet::</span>

<span class="sd">        xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[i,j], yv[i,j]</span>

<span class="sd">        xv, yv = np.meshgrid(x, y, indexing=&#39;xy&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[j,i], yv[j,i]</span>

<span class="sd">    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mgrid : Construct a multi-dimensional &quot;meshgrid&quot; using indexing notation.</span>
<span class="sd">    ogrid : Construct an open multi-dimensional &quot;meshgrid&quot; using indexing</span>
<span class="sd">            notation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nx, ny = (3, 2)</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 1, nx)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(0, 1, ny)</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[0. , 0.5, 1. ],</span>
<span class="sd">           [0. , 0.5, 1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[0.,  0.,  0.],</span>
<span class="sd">           [1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[0.],</span>
<span class="sd">           [1.]])</span>

<span class="sd">    `meshgrid` is very useful to evaluate functions on a grid.  If the</span>
<span class="sd">    function depends on all coordinates, you can use the parameter</span>
<span class="sd">    ``sparse=True`` to save memory and computation time.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-5, 5, 101)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(-5, 5, 101)</span>
<span class="sd">    &gt;&gt;&gt; # full coordinate arrays</span>
<span class="sd">    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2)</span>
<span class="sd">    &gt;&gt;&gt; xx.shape, yy.shape, zz.shape</span>
<span class="sd">    ((101, 101), (101, 101), (101, 101))</span>
<span class="sd">    &gt;&gt;&gt; # sparse coordinate arrays</span>
<span class="sd">    &gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2)</span>
<span class="sd">    &gt;&gt;&gt; xs.shape, ys.shape, zs.shape</span>
<span class="sd">    ((1, 101), (101, 1), (101, 101))</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(zz, zs)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; h = plt.contourf(x, y, zs)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;scaled&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Valid values for `indexing` are &#39;xy&#39; and &#39;ij&#39;.&quot;</span><span class="p">)</span>

    <span class="n">s0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s0</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
              <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># switch first and second axis</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="c1"># Return the full N-D matrix (not only the 1-D vector)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">_delete_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_delete_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with sub-arrays along an axis deleted. For a one</span>
<span class="sd">    dimensional array, this returns those entries not returned by</span>
<span class="sd">    `arr[obj]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : slice, int or array of ints</span>
<span class="sd">        Indicate indices of sub-arrays to remove along the specified axis.</span>

<span class="sd">        .. versionchanged:: 1.19.0</span>
<span class="sd">            Boolean indices are now treated as a mask of elements to remove,</span>
<span class="sd">            rather than being cast to the integers 0 and 1.</span>

<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to delete the subarray defined by `obj`.</span>
<span class="sd">        If `axis` is None, `obj` is applied to the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with the elements specified by `obj` removed. Note</span>
<span class="sd">        that `delete` does not occur in-place. If `axis` is None, `out` is</span>
<span class="sd">        a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    append : Append elements at the end of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Often it is preferable to use a boolean mask. For example:</span>

<span class="sd">    &gt;&gt;&gt; arr = np.arange(12) + 1</span>
<span class="sd">    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; mask[[0,2,4]] = False</span>
<span class="sd">    &gt;&gt;&gt; result = arr[mask,...]</span>

<span class="sd">    Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further</span>
<span class="sd">    use of `mask`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, 1, 0)</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>

<span class="sd">    &gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)</span>
<span class="sd">    array([[ 2,  4],</span>
<span class="sd">           [ 6,  8],</span>
<span class="sd">           [10, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, [1,3,5], None)</span>
<span class="sd">    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">arrorder</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>

    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">numtodel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numtodel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">arrorder</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">arrorder</span><span class="p">)</span>

        <span class="c1"># Invert if step is negative:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">step</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numtodel</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="c1"># copy initial chunk</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="c1"># copy end chunk</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="c1"># copy middle pieces</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># use array indexing.</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[:</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">:</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># `size == 0` to allow empty lists similar to indexing, but (as there)</span>
        <span class="c1"># is really too generic:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
            <span class="c1"># For a size 1 integer array we can use the single-value path</span>
            <span class="c1"># (most dtypes, except boolean, should just fail later).</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">single_value</span><span class="p">:</span>
        <span class="c1"># optimization for a single value</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">obj</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">%i</span><span class="s2"> is out of bounds for axis </span><span class="si">%i</span><span class="s2"> with &quot;</span>
                <span class="s2">&quot;size </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">+=</span> <span class="n">N</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;boolean array argument obj to delete &#39;</span>
                                 <span class="s1">&#39;must be one dimensional and match the axis &#39;</span>
                                 <span class="s1">&#39;length of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

            <span class="c1"># optimization, the other branch is slower</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">obj</span><span class="p">,]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_insert_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_insert_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert values along the given axis before the given indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : int, slice or sequence of ints</span>
<span class="sd">        Object that defines the index or indices before which `values` is</span>
<span class="sd">        inserted.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">        Support for multiple insertions when `obj` is a single scalar or a</span>
<span class="sd">        sequence with one element (similar to calling insert multiple</span>
<span class="sd">        times).</span>
<span class="sd">    values : array_like</span>
<span class="sd">        Values to insert into `arr`. If the type of `values` is different</span>
<span class="sd">        from that of `arr`, `values` is converted to the type of `arr`.</span>
<span class="sd">        `values` should be shaped so that ``arr[...,obj,...] = values``</span>
<span class="sd">        is legal.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to insert `values`.  If `axis` is None then `arr`</span>
<span class="sd">        is flattened first.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with `values` inserted.  Note that `insert`</span>
<span class="sd">        does not occur in-place: a new array is returned. If</span>
<span class="sd">        `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    append : Append elements at the end of an array.</span>
<span class="sd">    concatenate : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that for higher dimensional inserts ``obj=0`` behaves very different</span>
<span class="sd">    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from</span>
<span class="sd">    ``arr[:,[0],:] = values``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [2, 2],</span>
<span class="sd">           [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5)</span>
<span class="sd">    array([1, 5, 1, ..., 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5, axis=1)</span>
<span class="sd">    array([[1, 5, 1],</span>
<span class="sd">           [2, 5, 2],</span>
<span class="sd">           [3, 5, 3]])</span>

<span class="sd">    Difference between sequence and scalars:</span>

<span class="sd">    &gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [2, 2, 2],</span>
<span class="sd">           [3, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),</span>
<span class="sd">    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; b = a.flatten()</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])</span>
<span class="sd">    array([1, 1, 5, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])</span>
<span class="sd">    array([1, 1, 5, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting</span>
<span class="sd">    array([1, 1, 7, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4)</span>
<span class="sd">    &gt;&gt;&gt; idx = (1, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1)</span>
<span class="sd">    array([[  0, 999,   1,   2, 999,   3],</span>
<span class="sd">           [  4, 999,   5,   6, 999,   7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">arrorder</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="c1"># turn it into a range object</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to copy obj, because indices will be changed in-place</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="c1"># See also delete</span>
            <span class="c1"># 2012-10-11, NumPy 1.8</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;in the future insert will treat boolean arrays and &quot;</span>
                <span class="s2">&quot;array-likes as a boolean index instead of casting it to &quot;</span>
                <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
            <span class="c1"># Code after warning period:</span>
            <span class="c1">#if obj.ndim != 1:</span>
            <span class="c1">#    raise ValueError(&#39;boolean array argument obj to insert &#39;</span>
            <span class="c1">#                     &#39;must be one dimensional&#39;)</span>
            <span class="c1">#indices = np.flatnonzero(obj)</span>
        <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;index array argument obj to insert must be one dimensional &quot;</span>
                <span class="s2">&quot;or scalar&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;with size </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">N</span>

        <span class="c1"># There are some object array corner cases here, but we cannot avoid</span>
        <span class="c1"># that:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># broadcasting is very different here, since a[:,0,:] = ... behaves</span>
            <span class="c1"># very different from a[:,[0],:] = ...! This changes values so that</span>
            <span class="c1"># it works likes the second case. (here a[:,0:1,:])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">numnew</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
    <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Can safely cast the empty list to intp</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

    <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">N</span>

    <span class="n">numnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>   <span class="c1"># stable sort</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">order</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numnew</span><span class="p">)</span>

    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
    <span class="n">old_mask</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">old_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
    <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_mask</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_append_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_append_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append values to the end of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    values : array_like</span>
<span class="sd">        These values are appended to a copy of `arr`.  It must be of the</span>
<span class="sd">        correct shape (the same shape as `arr`, excluding `axis`).  If</span>
<span class="sd">        `axis` is not specified, `values` can be any shape and will be</span>
<span class="sd">        flattened before use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which `values` are appended.  If `axis` is not</span>
<span class="sd">        given, both `arr` and `values` are flattened before use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    append : ndarray</span>
<span class="sd">        A copy of `arr` with `values` appended to `axis`.  Note that</span>
<span class="sd">        `append` does not occur in-place: a new array is allocated and</span>
<span class="sd">        filled.  If `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    array([1, 2, 3, ..., 7, 8, 9])</span>

<span class="sd">    When `axis` is specified, `values` must have the correct shape.</span>

<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: all the input arrays must have same number of dimensions, but</span>
<span class="sd">    the array at index 0 has 2 dimension(s) and the array at index 1 has 1</span>
<span class="sd">    dimension(s)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_digitize_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_digitize_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the bins to which each value in input array belongs.</span>

<span class="sd">    =========  =============  ============================</span>
<span class="sd">    `right`    order of bins  returned index `i` satisfies</span>
<span class="sd">    =========  =============  ============================</span>
<span class="sd">    ``False``  increasing     ``bins[i-1] &lt;= x &lt; bins[i]``</span>
<span class="sd">    ``True``   increasing     ``bins[i-1] &lt; x &lt;= bins[i]``</span>
<span class="sd">    ``False``  decreasing     ``bins[i-1] &gt; x &gt;= bins[i]``</span>
<span class="sd">    ``True``   decreasing     ``bins[i-1] &gt;= x &gt; bins[i]``</span>
<span class="sd">    =========  =============  ============================</span>

<span class="sd">    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is</span>
<span class="sd">    returned as appropriate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input array to be binned. Prior to NumPy 1.10.0, this array had to</span>
<span class="sd">        be 1-dimensional, but can now have any shape.</span>
<span class="sd">    bins : array_like</span>
<span class="sd">        Array of bins. It has to be 1-dimensional and monotonic.</span>
<span class="sd">    right : bool, optional</span>
<span class="sd">        Indicating whether the intervals include the right or the left bin</span>
<span class="sd">        edge. Default behavior is (right==False) indicating that the interval</span>
<span class="sd">        does not include the right edge. The left bin end is open in this</span>
<span class="sd">        case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for</span>
<span class="sd">        monotonically increasing bins.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : ndarray of ints</span>
<span class="sd">        Output array of indices, of same shape as `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `bins` is not monotonic.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the type of the input is complex.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bincount, histogram, unique, searchsorted</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If values in `x` are such that they fall outside the bin range,</span>
<span class="sd">    attempting to index `bins` with the indices that `digitize` returns</span>
<span class="sd">    will result in an IndexError.</span>

<span class="sd">    .. versionadded:: 1.10.0</span>

<span class="sd">    `np.digitize` is  implemented in terms of `np.searchsorted`. This means</span>
<span class="sd">    that a binary search is used to bin the values, which scales much better</span>
<span class="sd">    for larger number of bins than the previous linear search. It also removes</span>
<span class="sd">    the requirement for the input array to be 1-dimensional.</span>

<span class="sd">    For monotonically _increasing_ `bins`, the following are equivalent::</span>

<span class="sd">        np.digitize(x, bins, right=True)</span>
<span class="sd">        np.searchsorted(bins, x, side=&#39;left&#39;)</span>

<span class="sd">    Note that as the order of the arguments are reversed, the side must be too.</span>
<span class="sd">    The `searchsorted` call is marginally faster, as it does not do any</span>
<span class="sd">    monotonicity checks. Perhaps more importantly, it supports all dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])</span>
<span class="sd">    &gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])</span>
<span class="sd">    &gt;&gt;&gt; inds = np.digitize(x, bins)</span>
<span class="sd">    &gt;&gt;&gt; inds</span>
<span class="sd">    array([1, 4, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; for n in range(x.size):</span>
<span class="sd">    ...   print(bins[inds[n]-1], &quot;&lt;=&quot;, x[n], &quot;&lt;&quot;, bins[inds[n]])</span>
<span class="sd">    ...</span>
<span class="sd">    0.0 &lt;= 0.2 &lt; 1.0</span>
<span class="sd">    4.0 &lt;= 6.4 &lt; 10.0</span>
<span class="sd">    2.5 &lt;= 3.0 &lt; 4.0</span>
<span class="sd">    1.0 &lt;= 1.6 &lt; 2.5</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])</span>
<span class="sd">    &gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])</span>
<span class="sd">    &gt;&gt;&gt; np.digitize(x,bins,right=True)</span>
<span class="sd">    array([1, 2, 3, 4, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.digitize(x,bins,right=False)</span>
<span class="sd">    array([1, 3, 3, 4, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

    <span class="c1"># here for compatibility, searchsorted below is happy to take this</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;x may not be complex&quot;</span><span class="p">)</span>

    <span class="n">mono</span> <span class="o">=</span> <span class="n">_monotonicity</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mono</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bins must be monotonically increasing or decreasing&quot;</span><span class="p">)</span>

    <span class="c1"># this is backwards because the arguments below are swapped</span>
    <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span> <span class="k">if</span> <span class="n">right</span> <span class="k">else</span> <span class="s1">&#39;right&#39;</span>
    <span class="k">if</span> <span class="n">mono</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># reverse the bins, and invert the results</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="n">_nx</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_nx</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
</pre></div>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By BrainPy Team
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
       Copyright 2020-2023, BrainPy.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
  Last updated on Apr 03, 2023.
  <br/>
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>